<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Z1Nhouse.github.io/</id>
    <title>Z1N&apos;s house</title>
    <updated>2020-01-11T14:47:16.149Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Z1Nhouse.github.io/"/>
    <link rel="self" href="https://Z1Nhouse.github.io//atom.xml"/>
    <subtitle>System.out.print(&quot;Welcome to Z1N&apos;s house！&quot;);</subtitle>
    <logo>https://Z1Nhouse.github.io//images/avatar.png</logo>
    <icon>https://Z1Nhouse.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Z1N&apos;s house</rights>
    <entry>
        <title type="html"><![CDATA[【JAVA】UVA 100 - The 3n+1 problem]]></title>
        <id>https://Z1Nhouse.github.io//post/ljIr-M6_B</id>
        <link href="https://Z1Nhouse.github.io//post/ljIr-M6_B">
        </link>
        <updated>2020-01-11T14:04:12.000Z</updated>
        <content type="html"><![CDATA[<p>題目原文：<a href="https://onlinejudge.org/index.php?Itemid=8&amp;option=com_onlinejudge&amp;page=show_problem&amp;problem=36">https://onlinejudge.org/index.php?Itemid=8&amp;option=com_onlinejudge&amp;page=show_problem&amp;problem=36</a></p>
<p><strong>Sample Input</strong><br>
1  10<br>
100  200<br>
201  210<br>
900  1000</p>
<p><strong>Sample Output</strong><br>
1  10  20<br>
100  200  125<br>
201  210  89<br>
900  1000  174</p>
<p><strong>題目大意：給定一個範圍(a~b)，範圍內所有整數都跑一遍3n+1問題，並計算每個數需要多少次迴圈才能得到1，最後輸出範圍內需跑迴圈數最多的值。</strong></p>
<p>3n+1跑法：如果n是奇數則n = 3n+1，否則n = n/2</p>
<p>注意：假設input為<code>22</code>，跑法則為：<code>22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1</code>，因此22的迴圈次數為16次(22本身也算1次)。</p>
<pre><code class="language-java">import java.util.*;
public class main{
    public static void main(String[] args) {
            Scanner sc=new Scanner(System.in);

            while(sc.hasNextInt()){
            
            int a=sc.nextInt(),b=sc.nextInt();
            
            if(a&gt;b){ //因為給定的兩數範圍並不一定是小到大,若a&gt;b需要做調換動作
            int c = a;
            a = b;
            b = c;
            }

            int aa=a,bb=b,max=0; //將調換後的a,b存入aa,bb , max為最大迴圈數

            for(int i = a;i&lt;=b ; i++){
            	int n = i;
            	int l = 1;
            	while(true){
            	
            	if(n==1)break;
            	l++;

            	if(n%2==0){
            	n = n/2;
            	}else{
            	n = n*3+1;
            	}
            	
            	if(l&gt;max){
            	max = l;
            	}
            	
            	}
            }
            System.out.println(aa+&quot; &quot;+bb+&quot; &quot;+max);
            }
       
    }
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【JAVA】UVA 10035 - Primary Arithmetic]]></title>
        <id>https://Z1Nhouse.github.io//post/VOy2ZIurR</id>
        <link href="https://Z1Nhouse.github.io//post/VOy2ZIurR">
        </link>
        <updated>2020-01-11T13:21:24.000Z</updated>
        <content type="html"><![CDATA[<p>題目原文：<a href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=12&amp;page=show_problem&amp;problem=976">https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=12&amp;page=show_problem&amp;problem=976</a></p>
<p><strong>Sample Input</strong><br>
123 456<br>
555 555<br>
123 594<br>
0 0<br>
<strong>Sample Output</strong><br>
No carry operation.<br>
3 carry operations.<br>
1 carry operation.</p>
<p><strong>題目大意：判斷兩整數相加後產生多少個進位，當兩數皆為0則停止程式。</strong><br>
<code>特別要注意的是，本題所有變數都為int，因此不會有小數的出現。</code></p>
<p>以<code>123+456</code>作為範例，首先第一輪sum=123%10+456%10+carry = 3+6+0 = 9 , sum沒有大於10所以carries保持為0,carry=sum/10所以也是0 , 接著a = a/10 =&gt; 123/10 = 12, b = b/10 =&gt; 456/10 = 45;</p>
<p>第二輪sum = 12%10+45%10+carry = 2+5+0 = 7 , carry=0,carries=0 , a = 12/10 = 1 , b = 45/10 = 4;</p>
<p>第三輪sum = 1%10+4%10+carry = 1+4+0 = 5 ,carry=0,carries=0 , a = 1/10 = 0 , b = 4/10 = 0 , 是以a與b皆為0，程式結束。</p>
<p>而最終carries = 0  , 所以output為No carry operation.</p>
<figure data-type="image" tabindex="1"><img src="https://Z1Nhouse.github.io//post-images/1578750760319.png" alt=""></figure>
<pre><code class="language-java">import java.util.*;
public class main{
    public static void main(String[] args) {
            Scanner sc=new Scanner(System.in);
            
            while(true){
            int a=sc.nextInt(),b=sc.nextInt();
            if(a==0&amp;&amp;b==0){ //當兩數皆為0則停止程式
            	break;
            }
        	
        	int carry=0,carries=0;
        	
        	while(a!=0||b!=0){ //a或者b任意一個不為0則繼續判斷
        	
        	int sum = a%10+b%10+carry; //從個位數慢慢往前推,判斷有無進位
        	
        	if(sum&gt;=10){
        		++carries;
        	}
        	
        	carry = sum/10;
        	a /= 10;  // a=a/10 每判斷完一個位數,就將它捨去
        	b /= 10;  // b=b/10 每判斷完一個位數,就將它捨去
        	
        	}
        	
        	if(carries==0){
        	System.out.println(&quot;No carry operation.&quot;);
        	}else if(carries==1){
        	System.out.println(&quot;1 carry operation.&quot;);
        	}else{
        	System.out.println(carries + &quot; carry operations.&quot;);
        	}
            
            }
           
        }
    }

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【JAVA】UVA 10055 - Hashmat the Brave Warroir]]></title>
        <id>https://Z1Nhouse.github.io//post/oOp8OrXuI</id>
        <link href="https://Z1Nhouse.github.io//post/oOp8OrXuI">
        </link>
        <updated>2020-01-11T13:12:08.000Z</updated>
        <content type="html"><![CDATA[<p>題目原文：<a href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=996">https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=996</a></p>
<p><strong>Sample Input</strong><br>
10 12<br>
10 14<br>
100 200<br>
<strong>Sample Output</strong><br>
2<br>
4<br>
100</p>
<p>題目大意：取兩數差，題目限制最大值為2^32，因此需要使用long。</p>
<pre><code class="language-java">import java.util.*;
public class main{
    public static void main(String[] args) {
            Scanner sc=new Scanner(System.in);
            while(sc.hasNextLong()){
            long a = sc.nextLong(),b = sc.nextLong();
    		System.out.println(Math.abs(a-b));
    		}
    }
};

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【JAVA】UVA 10041 - Vito's Family]]></title>
        <id>https://Z1Nhouse.github.io//post/UNd1D1Awb</id>
        <link href="https://Z1Nhouse.github.io//post/UNd1D1Awb">
        </link>
        <updated>2020-01-11T13:00:40.000Z</updated>
        <content type="html"><![CDATA[<p>UVa10041 Vito's family 題目原文：<a href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=982">https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=982</a></p>
<p><strong>Sample Input</strong><br>
2<br>
2 2 4<br>
3 2 4 6<br>
<strong>Sample Output</strong><br>
2<br>
4</p>
<p>解題順序：</p>
<ol>
<li>先將成員由小到大排序</li>
<li>找出該組成員的中位數</li>
<li>輸出中位數成員到各成員的距離總和。</li>
</ol>
<p>現在來看範例：<br>
<strong>Sample Input</strong><br>
2  <code>&lt;--這邊的2指的是有兩組要比對的資料</code><br>
2 2 4     <code>&lt;--第一個2表示該組有2個成員，分別為2,4</code><br>
3 2 4 6   <code>&lt;--該組有3個成員，分別為2,4,6</code><br>
<strong>Sample Output</strong><br>
2 <code>以2為中位數，所有成員與2的距離為|4-2|=2</code><br>
4 <code>以4為中位數，所有成員與4的距離為|2-4|+|6-4|=4</code></p>
<p>當成員數為偶數時，中間兩個數任意選一個即可。</p>
<pre><code class="language-java">import java.util.*;
public class main{
    public static void main(String[] args) {
     
            Scanner sc=new Scanner(System.in);
            int n= sc.nextInt(); //共幾組
            while((--n)&gt;=0){
            
            int p = sc.nextInt(); //幾個成員
            int house[] = new int[p]; //令一個成員數大小的陣列
            
            for(int i = 0 ; i&lt;p ; i++){
            	house[i] = sc.nextInt(); //輸入成員的值
            }
            
            Arrays.sort(house); //將成員由小到大排序
            
            int len=0;
            
            for(int i = 0 ; i&lt;p ; i++){
            	len+=Math.abs(house[i]-house[i/2]); //計算所有成員與中位數的絕對值距離總和
            }
            System.out.println(len);
            }
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何使用JS讓PHP表單內容填寫空白時跳出提醒？]]></title>
        <id>https://Z1Nhouse.github.io//post/gd_Z3CfkC</id>
        <link href="https://Z1Nhouse.github.io//post/gd_Z3CfkC">
        </link>
        <updated>2020-01-09T06:28:52.000Z</updated>
        <content type="html"><![CDATA[<p>直接上代碼，應該不需要解釋了吧。</p>
<p>先在<code>&lt;body&gt;..&lt;/body&gt;</code>之間新建一個表單：</p>
<pre><code>&lt;form method=&quot;POST&quot; action=&quot;alert1.php&quot; name=&quot;Regist&quot; onsubmit=&quot;return formcheck();&quot;&gt;

帳號：&lt;input type=&quot;text&quot; name=&quot;id&quot;&gt;
&lt;input type=&quot;submit&quot; value=&quot;送出&quot;&gt;

&lt;/form&gt;
</code></pre>
<p>在<code>&lt;head&gt;...&lt;/head&gt;</code>之間插入function：</p>
<pre><code>&lt;script language=&quot;javascript&quot;&gt;

function formcheck(){

    if(Regist.id.value==&quot;&quot;){
        alert(&quot;請填寫帳號！&quot;);
        Regist.id.focus();  //focus到錯誤欄位
        return false;
    }
    return true;
}

&lt;/script&gt;
</code></pre>
<p>如此一來只要帳號欄位空白送出時，瀏覽器就會跳出提醒視窗&quot;請填寫帳號!&quot;，並且focus到帳號欄位。</p>
<figure data-type="image" tabindex="1"><img src="https://Z1Nhouse.github.io//post-images/1578551667434.PNG" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[帶你兩分鐘了解什麼是關聯式資料庫？]]></title>
        <id>https://Z1Nhouse.github.io//post/IPygPpR2t</id>
        <link href="https://Z1Nhouse.github.io//post/IPygPpR2t">
        </link>
        <updated>2020-01-09T06:16:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id="關聯式資料庫簡介">關聯式資料庫簡介</h2>
<p>關聯式資料庫（Relational database）是建立在<strong>關聯模型</strong>基礎上的資料庫，藉助於集合代數等數學概念和方法來處理資料庫中的資料。<br>
現如今雖然對此模型有一些批評意見，但它還是資料儲存的傳統標準。<br>
標準資料查詢語言<strong>SQL</strong>就是一種基於關聯式資料庫的語言，這種語言執行對關聯式資料庫中資料的檢索和操作。</p>
<h2 id="關係鍵">關係鍵</h2>
<p>其實還有其他關係鍵，但這邊暫且用不到，所以只介紹主鍵與外鍵。</p>
<ul>
<li>
<p><code>主鍵(primary key)</code>資料庫表中對儲存資料物件予以唯一和完整標識的資料列或屬性的組合。<br>
一個資料表<strong>只能有一個主鍵，且主鍵的取值不能缺失，即不能為空值（Null）</strong>。</p>
</li>
<li>
<p><code>外鍵(foreign key)</code>是關聯式資料庫的重要組成部分。在關聯式資料庫中，每個資料表都是由關聯來連繫彼此的關係，父資料表（Parent Entity）的主鍵（primary key）會放在另一個資料表，當做屬性以建立彼此的關聯，而這個屬性就是外來鍵。</p>
</li>
</ul>
<h2 id="圖解">圖解</h2>
<p><img src="https://Z1Nhouse.github.io//post-images/1578550721047.png" alt=""><br>
事實上，departments還可以再增加許多內容，比如科系主任、科系教授數量...等。</p>
<p>students資料表的科系代碼欄位是屬於外鍵，departments資料表的科系代碼則是主鍵，students的外鍵對應到departments的主鍵，可以省略很多重複的資料。</p>
<p>之所以需要使用關聯資料表，是因為我們不希望在學生資料上記載關於科系的詳細資料，這兩份資料表有各自明確的功能，我們只需要創造兩張表的&quot;關聯&quot;，就可以在必要的時候查找資訊。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用jQuery取得JSON資料 - 簡易隨機詩詞產生器]]></title>
        <id>https://Z1Nhouse.github.io//post/Oj8rJWuki</id>
        <link href="https://Z1Nhouse.github.io//post/Oj8rJWuki">
        </link>
        <updated>2020-01-01T16:03:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什麼是jquery">什麼是jQuery</h2>
<p>jQuery是繼prototype之後又一個優秀的Javascript庫。它是輕量級的js庫，它兼容CSS3，還兼容各種瀏覽器（IE 6.0+, FF1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及後續版本將不再支持IE6/ 7/8瀏覽器。<br>
　　jQuery使用戶能更方便地處理HTML、events、實現動畫效果，並且方便地為網站提供AJAX交互。jQuery還有一個比較大的優勢是，它的文檔說明很全，而且各種應用也說得很詳細，同時還有許多成熟的插件可供選擇。 jQuery能夠使用戶的html頁面保持代碼和html內容分離，也就是說，不用再在html裡面插入一堆js來調用命令了，只需要定義id即可。</p>
<p>jquery官網提供2種jQuery的下載，一種是jquery.js另一種是jquery.min.js。</p>
<p>文件名不一定完全相同，但通常情況下：</p>
<ul>
<li>
<p>jquery.js是完整的未壓縮的jQuery庫，文件比較大，一般用於閱讀學習源碼或修改源碼，一般不用於線上項目。</p>
</li>
<li>
<p>jquery.min.js是由完整版的jQu​​ery庫經過壓縮得來，壓縮後功能與未壓縮的完全一樣，只是將其中的空白字符、註釋、空行等與邏輯無關的內容刪除，並進行一些優化。這個版本一般用於網站引用使用，減小文件體積，降低網站流量，提升訪問速度等。</p>
</li>
</ul>
<h2 id="載入jquery">載入jQuery</h2>
<p>使用jQuery時你必須先將jQuery加進網頁的<code>&lt;head&gt;..&lt;/head&gt;</code>之間。</p>
<pre><code>&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>當然你可以選擇將jquery.min.js下載上傳至網站直接使用，也可以藉由CDN載入。<br>
使用CDN載入的好處是若不同的網站使用同樣的連結時可以避免重複下載，也不必在自己的伺服器上部署jQuery檔案。</p>
<h2 id="隨機詩詞產生器">隨機詩詞產生器</h2>
<p>當然這就需要API了，我們以今日詩詞的API作為示範：</p>
<ul>
<li><a href="https://www.jinrishici.com/">今日詩詞官網</a></li>
<li><a href="https://www.jinrishici.com/doc/">今日詩詞使用說明</a></li>
</ul>
<p>以下為使用jQuery取得JSON資料的寫法，放在<code>&lt;head&gt;..&lt;/head&gt;</code>：</p>
<pre><code class="language-javascript">&lt;script type=&quot;text/javascript&quot;&gt;
function nextshi(){
  $.getJSON(&quot;https://v1.jinrishici.com/all.json&quot;,function(json){ //替換API的位址

 /*json為function的名稱,後面接JSON中的類別,使用點(.)相連*/
   category = json.category;    //分類
   author = json.author;        //作者
   content = json.content;      //內容
   origin = json.origin; //原文

/*使用json取得的資料改變元素的內容*/
   $(&quot;.shi-content&quot;).html(content); 
   $(&quot;.shi-author&quot;).html(author);
   $(&quot;.shi-category&quot;).html(category);
   $(&quot;.shi-origin&quot;).html(origin);
  });
 }
&lt;/script&gt;
</code></pre>
<p></p>
因為我們設定了shi-content、shi-author、shi-category、shi-origin這四個元素，因此我們也需要在網頁中插入相對應的呼叫，只需要使用 class="shi-origin" (以此類推)。
<p>以下為放在<code>&lt;body&gt;...&lt;/body&gt;</code>的內容：</p>
<pre><code class="language-html">&lt;h1&gt;&lt;ins class=&quot;shi-origin&quot;&gt;標題&lt;/ins&gt;&lt;/h1&gt;
&lt;cite class=&quot;shi-author&quot;&gt;作者&lt;/cite&gt;
&lt;br&gt;
&lt;blockquote&gt;
&lt;div class=&quot;shi-content&quot;&gt;內文&lt;/div&gt;
&lt;/blockquote&gt;
分類：&lt;font class=&quot;shi-category&quot;&gt;&lt;/font&gt;

&lt;p&gt;
&lt;button onclick=&quot;javascript:nextshi();&quot;&gt;Random&lt;/button&gt; //使用按鈕來隨機產生
</code></pre>
<h1>範例效果</h1>
<ol>
<li>未按按鈕前<br>
<img src="https://Z1Nhouse.github.io//post-images/1577895935822.PNG" alt=""></li>
<li>隨機產生後<br>
<img src="https://Z1Nhouse.github.io//post-images/1577895939269.PNG" alt=""></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【資料結構】圖形結構(Graph)基礎篇(3) - 最短路徑(Shortest Paths)]]></title>
        <id>https://Z1Nhouse.github.io//post/W9lvX_AV-</id>
        <link href="https://Z1Nhouse.github.io//post/W9lvX_AV-">
        </link>
        <updated>2019-12-30T13:39:35.000Z</updated>
        <content type="html"><![CDATA[<p>勤奮編輯中....!</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【資料結構】圖形結構(Graph)基礎篇(2) - 擴張樹(Spanning Tree)]]></title>
        <id>https://Z1Nhouse.github.io//post/p0rM7JmKv</id>
        <link href="https://Z1Nhouse.github.io//post/p0rM7JmKv">
        </link>
        <updated>2019-12-30T13:13:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="擴張樹spanning-tree">✨擴張樹(Spanning Tree)</h2>
<p>擴張樹(Spanning Tree)又稱花費樹，一個圖形的擴張樹是以最少的邊來連結圖形中所有的頂點(且須避免循環)。</p>
<ol>
<li>一棵包含圖上所有頂點的樹，稱作該圖的擴張樹。</li>
<li>一張圖的擴張樹可能會有很多種。</li>
<li>完全連通圖才有擴張樹 (不連通時，則稱為擴張森林)。</li>
<li>擴張樹的權重為樹上每條邊的權重總和。</li>
</ol>
<p>假設今天有n個頂點的無向圖形擴張樹，則會有n-1個邊。<br>
使用BFS方式追蹤產生的擴張樹稱為寬度優先擴張樹；使用DFS追蹤產生的擴張樹則稱為深度優先擴張樹。</p>
<h2 id="花費最少擴張樹minimum-spanning-tree">✨花費最少擴張樹(Minimum Spanning Tree)</h2>
<p>一副<strong>連通加權無向圖</strong>中擁有最小成本(權重)的擴張樹就稱為花費最少擴張樹。<br>
那麼為何需要找到花費最少擴張樹？<br>
因為很多情境都可由圖形來表示，例如從台北到西班牙轉機的距離就可以以此找出花費最少的方法。</p>
<p>找出一個加權圖形中花費最少擴張樹可以利用以下三種演算法(當然不止這三種)：</p>
<ol>
<li>Kruskal's Algorithm</li>
<li>Prim's Algorithm</li>
<li>Sollin's Algorithm</li>
</ol>
<p>這三種演算法皆是greedy algorithm(貪婪法則)。</p>
<h3 id="kruskals-algorithm">🌸Kruskal's Algorithm</h3>
<p>這個演算法較容易實作，由Spanning tree中<strong>花費最少的邊</strong>出發，每一次都選擇目前尚未被選擇的最少花費的邊，且避免形成循環，直到邊的個數為n-1(頂點為n)即找出花費最少擴張樹。</p>
<p><img src="https://Z1Nhouse.github.io//post-images/1577711708165.gif" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1577711903994.gif" alt=""></p>
<h3 id="prims-algorithm">🌸Prim's Algorithm</h3>
<p>先從Spanning tree中找一個頂點V作為起始點，找出與V相連且還沒有被選取的頂點裡面加權值最小的邊，直到找到n-1個邊(頂點為n)。</p>
<p><img src="https://Z1Nhouse.github.io//post-images/1577711713650.gif" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1577711910898.gif" alt=""></p>
<h3 id="sollins-algorithm">🌸Sollin's Algorithm</h3>
<p>每次選擇花費最少的子圖，並且再選取花費較少的邊將這些子圖相連(不能造成循環)，直到邊數為n-1(頂點為n)停止。</p>
<figure data-type="image" tabindex="1"><img src="https://Z1Nhouse.github.io//post-images/1577712145202.gif" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【資料結構】圖形結構(Graph)基礎篇(1)]]></title>
        <id>https://Z1Nhouse.github.io//post/BFgV-T9ON</id>
        <link href="https://Z1Nhouse.github.io//post/BFgV-T9ON">
        </link>
        <updated>2019-12-24T12:35:04.000Z</updated>
        <summary type="html"><![CDATA[<p>起源為瑞士的數學家尤拉解決Koenigsberg bridge problem(七橋問題)。<br>
圖形結構提供了簡單的方式來描述一個問題、系統或狀況等。<br>
與樹狀結構的差異為，樹狀結構是描述節點與節點之間的層次關係。</p>
]]></summary>
        <content type="html"><![CDATA[<p>起源為瑞士的數學家尤拉解決Koenigsberg bridge problem(七橋問題)。<br>
圖形結構提供了簡單的方式來描述一個問題、系統或狀況等。<br>
與樹狀結構的差異為，樹狀結構是描述節點與節點之間的層次關係。</p>
<!-- more -->
<h2 id="定義與種類">📜定義與種類</h2>
<p>一個圖形是由頂點集合V與邊集合E所組成，數學上通常用G = (V,E)表示。</p>
<p>圖形結構具有以下特徵：</p>
<ol>
<li>基本上是由頂點(Vertices)與邊(Edges)兩個部分所構成。</li>
<li>有方向性稱為有向圖(Directed Graph)、無方向性稱為無向圖(Undirected Graph)。</li>
<li>圖形的特點之一為資料也可以儲存在個別<strong>邊</strong>上。邊上的資料可以表示從這個邊的一個頂點至另一個頂點的花費(cost)。這種成本存在邊上的圖形稱為｢網路」。</li>
</ol>
<p>下方為示意圖：<br>
<img src="https://Z1Nhouse.github.io//post-images/1577190922243.PNG" alt=""></p>
<p>依據線段(Edge)有沒有方向性可分為<strong>無向圖</strong>及<strong>有向圖</strong>：</p>
<ul>
<li>
<p><strong>無向圖(Undirected graph)</strong><br>
邊集合中的每一個邊都沒有方向性。</p>
</li>
<li>
<p><strong>有向圖(Directed graph)</strong><br>
邊集合中的每一個編都有方向性，以指向下一個頂點。</p>
</li>
</ul>
<p>此無向圖G1的點集合與邊集合為：<br>
<img src="https://Z1Nhouse.github.io//post-images/1577190934860.png" alt=""><br>
V(G1)={1,2,3,4,5,6}<br>
E(G1)={(1,2), (1,3),(2,4),(3,4),(3,5),(4,5),(4,6)}</p>
<p>此有向圖G2的點集合與邊集合為：<br>
<img src="https://Z1Nhouse.github.io//post-images/1577191098864.png" alt=""><br>
V(G2)={1,2,3,4}<br>
E(G2)={(1,2), (1,3),(3,2),(3,4),(4,3)}</p>
<p>樹也是一種圖，但是樹可以出現環、連通，而樹不行。<br>
注意，圖形不能有自我迴圈(self-loop)。</p>
<h3 id="圖形結構的用詞">💬圖形結構的用詞</h3>
<p>圖(1)<br>
<img src="https://Z1Nhouse.github.io//post-images/1577191098864.png" alt=""><br>
圖(2)<br>
<img src="https://Z1Nhouse.github.io//post-images/1577191142220.png" alt=""></p>
<ul>
<li><strong>頂點(Vertex)</strong>：也可稱為資料節點(Node)，例如圖(1)的1,2,3,4。</li>
<li><strong>邊(Edge)</strong>：每個頂點的連線就稱為邊。</li>
<li><strong>相鄰(Adjacent)</strong>：例如圖(2)的1,2相鄰。</li>
<li><strong>路徑(Path)</strong>：某個頂點到某個頂點的過程。</li>
<li><strong>連通(Connected)</strong>：在一&quot;無向圖&quot;中，任何成對頂點之間皆有路徑存在。<br>
<img src="https://Z1Nhouse.github.io//post-images/1577191912704.PNG" alt=""></li>
</ul>
<ol>
<li>
<p>強連通(Strongly connected)：<br>
在&quot;有向圖&quot;中，<strong>任何</strong>成對頂點之間皆有路徑可以相互到達對方。<br>
<img src="https://Z1Nhouse.github.io//post-images/1577192024532.PNG" alt=""></p>
</li>
<li>
<p>弱連通(Weakly connected)：<br>
在&quot;有向圖&quot;中，<strong>至少</strong>有兩個頂點無法以有向路徑相互到達對方。</p>
</li>
</ol>
<ul>
<li>
<p><strong>簡單路徑(Simple path)</strong>：路徑上除了起點和終點可以相同之外，其餘頂點均不相同。<br>
<img src="https://Z1Nhouse.github.io//post-images/1577191244570.png" alt=""></p>
</li>
<li>
<p><strong>循環(Cycle)</strong>：若有一條簡單路徑的起點頂點與終點頂點相同，則稱這條路徑為cycle。</p>
</li>
<li>
<p><strong>分支度(Degree)</strong>：(無向圖)為連接至該頂點的邊之個數。比如圖(2)，1的分支度為&quot;2&quot;，4的分支度為&quot;4&quot;。<br>
有向圖還會區分為外分支度(Outdegree)與內分支度(Indegree)。</p>
</li>
<li>
<p><strong>子圖(Subgraph)</strong>：圖中的某一部分。<br>
<img src="https://Z1Nhouse.github.io//post-images/1577191627812.PNG" alt=""></p>
</li>
<li>
<p><strong>完整圖(Complete Graph)</strong>：是一個擁有最多非重複邊線的圖：</p>
</li>
</ul>
<ol>
<li>無向圖：若圖具有n個頂點，則具有最多的非重複邊個數達<code>n(n-1)/2</code>時，此圖稱為完整圖。</li>
<li>有向圖：若圖具有n個頂點，則具有最多的非重複邊個數達<code>n(n-1)</code>時，此圖稱為完整圖。<br>
<img src="https://Z1Nhouse.github.io//post-images/1577191576654.gif" alt=""></li>
</ol>
<h2 id="表示方式">🔎表示方式</h2>
<p>常用的表示方式：相鄰矩陣(Adjacency Matrix)、相鄰串列(Adjacency List)</p>
<h3 id="相鄰矩陣adjacency-matrix">🎈相鄰矩陣(Adjacency Matrix)</h3>
<p>對無向圖而言，根據項點數n，宣告一個n×n的二維矩陣。<br>
矩陣中，每個1就代表該兩個項點有連線。<br>
<img src="https://Z1Nhouse.github.io//post-images/1577192189083.PNG" alt=""></p>
<ul>
<li>無向圖的相鄰矩陣必為對稱(Symmetric)，對角線皆為0，因為自己與自己本身無法相連(<code>A[1][1]、A[2][2]....A[i][j]</code>)其儲存空間為<code>n(n-1)/2</code>。</li>
<li>有向圖的相鄰矩陣不一定為對稱，但當有向圖為完整圖時也會是對稱矩陣。</li>
</ul>
<h3 id="相鄰串列adjacency-list">🎈相鄰串列(Adjacency List)</h3>
<p>有幾個頂點(n)就需要幾條相鄰串列與一個大小為n的一維陣列，其中A[i] 所存放的是頂點i 的相鄰串列，此串列中毎個Node皆記録著與頂點i 相鄰之其它頂點。</p>
<ol>
<li>
<p>無向<br>
<img src="https://Z1Nhouse.github.io//post-images/1577192594214.gif" alt=""></p>
</li>
<li>
<p>有向<br>
<img src="https://Z1Nhouse.github.io//post-images/1577192729326.gif" alt=""></p>
</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://Z1Nhouse.github.io//post-images/1577192986524.PNG" alt=""></figure>
<h2 id="圖形追蹤traverse-graph">📍圖形追蹤(Traverse Graph)</h2>
<p>圖形中的所有頂點都被拜訪到，且僅被拜訪到一次。<br>
分為DFS深先搜尋與BFS廣先搜尋。</p>
<h3 id="深先搜尋depth-first-search">📌<strong>深先搜尋(Depth First Search)</strong></h3>
<p>包含<strong>遞迴應用</strong>的概念，因此可利用<code>堆疊(Stack)</code>保存走訪過程中間所走過的點。</p>
<p>如同前序追蹤，先遇到的頂點就先探索，如果節點有子節點，首先對其進行探索。<br>
除非另有說明，否則通常從左到右。<br>
如果從任何已走訪過的頂點，都無法再走訪到一個尚未被走過的頂點時，則結束走訪。</p>
<figure data-type="image" tabindex="2"><img src="https://Z1Nhouse.github.io//post-images/1577193694728.png" alt=""></figure>
<p>PS.DFS之順序並不唯一除非規定“拜訪時，依Node編號由小到大拜訪”才會唯一。</p>
<p>我們可以利用DFS進行**拓撲排序(Topological Sort)**也可找到有向圖中的Strongly Connected Component(SCC)。</p>
<h3 id="廣先搜尋breadth-first-search">📌<strong>廣先搜尋(Breadth First Search)</strong></h3>
<p>BFS是廣義的層級探索(Level-Order Traversal)，將之從樹推廣至圖。<br>
BFS運作流程基本上與DFS差不多，但BFS是利用<code>佇列(Queue)</code>保存走訪過程中間所走過的點。</p>
<p>由起始頂點15 開始走訪。<br>
所有相鄰至15且尚未被拜訪過的頂點，都會在下個步驟裡一一被走訪。<br>
而相鄰至這些被走訪頂點且尚未走過的頂點，又將被一一走訪；重複上述，直到無頂點可被拜訪為止。<br>
<img src="https://Z1Nhouse.github.io//post-images/1577194220398.jpg" alt=""></p>
<h2 id="aov-networks與toplogical">🔸AOV Networks與Toplogical</h2>
<p>AOV全稱Activity On Vertex，假設G = &lt;V, E&gt;為一個&quot;有向圖&quot;，其中<strong>頂點</strong>表示工作(Activity)，<strong>線段</strong>表示工作執行之先後次序關係。<br>
<img src="https://Z1Nhouse.github.io//post-images/1577195363117.png" alt=""></p>
<p>應用: 求合理的工作執行順序，即：<strong>拓樸順序(Topological Order)</strong></p>
<p><strong>🔸拓樸順序(Topological Order)</strong></p>
<ol>
<li>找出一個無前導(內分支度為0)的頂點將此頂點輸出。</li>
<li>刪除此點及其線段。</li>
<li>直到所有頂點已輸出，或剩下的點皆有前導存在。</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://Z1Nhouse.github.io//post-images/1577196549261.png" alt=""></figure>
<ul>
<li>若AOV Network有cycle，則無Topological Order。(<code>∵無法決定誰先做</code>)</li>
<li>不具cycle的AOV Network，其Topological Order ≥1組。(<code>不一定唯一</code>)</li>
</ul>
<h2 id="aoe-networks">🔹AOE Networks</h2>
<p>AOE全稱Activity On Edge，在<code>有加權的有向圖</code>上以Edge表示工作(Activity)，Vertex表示事件(Event)，Edge上具有加權值，表示工作完成所需的時間。<strong>與AOV不同之處在於，AOV以Vertex表示工作，而AOE是以Edge表示工作。</strong></p>
<figure data-type="image" tabindex="4"><img src="https://Z1Nhouse.github.io//post-images/1577196821362.png" alt=""></figure>
<p><strong>完成此計畫所需之最少(最起碼)的工作時數?</strong><br>
求從<code>Start → End</code>事件之最長路徑長度即：求<code>Critical path (臨界路徑)</code>的長度。</p>
<p>上圖有可能的路徑為</p>
<ol>
<li>0→1→4→5→6 (持續時間=15)</li>
<li>0→1→2→5→6 (持續時間=16)</li>
<li>0→2→5→6 (持續時間=13)</li>
<li>0→2→3→5→6 (持續時間=20)</li>
<li>0→3→5→6 (持續時間=17)</li>
</ol>
<p>最長路徑的長度為20，因此有一條路徑為<code>Critical path(臨界路徑)</code>。</p>
<p>由於在AOE Networks中有些活動可以並列地進行，所以完成工程的最短時間是從開始點到完成點的最長路徑的長度（路徑上各活動持續時間之和）。路徑長度最長的路徑叫做<code>關鍵路徑</code>。</p>
<h3 id="最早開始最脕開始時間">最早開始/最脕開始時間</h3>
<p>在AOE網路上所有的活動皆有的時間，最晚開始時間指一活動在不影響整個計畫完成之下，最晚能夠開始進行的時間。</p>
<figure data-type="image" tabindex="5"><img src="https://Z1Nhouse.github.io//post-images/1577196821362.png" alt=""></figure>
<p>以上圖計算最早及最晚時間，結果如下：</p>
<figure data-type="image" tabindex="6"><img src="https://Z1Nhouse.github.io//post-images/1577367557250.PNG" alt=""></figure>
]]></content>
    </entry>
</feed>