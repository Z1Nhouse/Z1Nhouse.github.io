<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Z1Nhouse.github.io/</id>
    <title>Z1N&apos;s house</title>
    <updated>2020-01-04T08:59:30.695Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Z1Nhouse.github.io/"/>
    <link rel="self" href="https://Z1Nhouse.github.io//atom.xml"/>
    <subtitle>System.out.print(&quot;Welcome to Z1N&apos;s house！&quot;);</subtitle>
    <logo>https://Z1Nhouse.github.io//images/avatar.png</logo>
    <icon>https://Z1Nhouse.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, Z1N&apos;s house</rights>
    <entry>
        <title type="html"><![CDATA[使用jQuery取得JSON資料 - 簡易隨機詩詞產生器]]></title>
        <id>https://Z1Nhouse.github.io//post/Oj8rJWuki</id>
        <link href="https://Z1Nhouse.github.io//post/Oj8rJWuki">
        </link>
        <updated>2020-01-01T16:03:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什麼是jquery">什麼是jQuery</h2>
<p>jQuery是繼prototype之後又一個優秀的Javascript庫。它是輕量級的js庫，它兼容CSS3，還兼容各種瀏覽器（IE 6.0+, FF1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及後續版本將不再支持IE6/ 7/8瀏覽器。<br>
　　jQuery使用戶能更方便地處理HTML、events、實現動畫效果，並且方便地為網站提供AJAX交互。jQuery還有一個比較大的優勢是，它的文檔說明很全，而且各種應用也說得很詳細，同時還有許多成熟的插件可供選擇。 jQuery能夠使用戶的html頁面保持代碼和html內容分離，也就是說，不用再在html裡面插入一堆js來調用命令了，只需要定義id即可。</p>
<p>jquery官網提供2種jQuery的下載，一種是jquery.js另一種是jquery.min.js。</p>
<p>文件名不一定完全相同，但通常情況下：</p>
<ul>
<li>
<p>jquery.js是完整的未壓縮的jQuery庫，文件比較大，一般用於閱讀學習源碼或修改源碼，一般不用於線上項目。</p>
</li>
<li>
<p>jquery.min.js是由完整版的jQu​​ery庫經過壓縮得來，壓縮後功能與未壓縮的完全一樣，只是將其中的空白字符、註釋、空行等與邏輯無關的內容刪除，並進行一些優化。這個版本一般用於網站引用使用，減小文件體積，降低網站流量，提升訪問速度等。</p>
</li>
</ul>
<h2 id="載入jquery">載入jQuery</h2>
<p>使用jQuery時你必須先將jQuery加進網頁的<code>&lt;head&gt;..&lt;/head&gt;</code>之間。</p>
<pre><code>&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>當然你可以選擇將jquery.min.js下載上傳至網站直接使用，也可以藉由CDN載入。<br>
使用CDN載入的好處是若不同的網站使用同樣的連結時可以避免重複下載，也不必在自己的伺服器上部署jQuery檔案。</p>
<h2 id="隨機詩詞產生器">隨機詩詞產生器</h2>
<p>當然這就需要API了，我們以今日詩詞的API作為示範：</p>
<ul>
<li><a href="https://www.jinrishici.com/">今日詩詞官網</a></li>
<li><a href="https://www.jinrishici.com/doc/">今日詩詞使用說明</a></li>
</ul>
<p>以下為使用jQuery取得JSON資料的寫法，放在<code>&lt;head&gt;..&lt;/head&gt;</code>：</p>
<pre><code class="language-javascript">&lt;script type=&quot;text/javascript&quot;&gt;
function nextshi(){
  $.getJSON(&quot;https://v1.jinrishici.com/all.json&quot;,function(json){ //替換API的位址

 /*json為function的名稱,後面接JSON中的類別,使用點(.)相連*/
   category = json.category;    //分類
   author = json.author;        //作者
   content = json.content;      //內容
   origin = json.origin; //原文

/*使用json取得的資料改變元素的內容*/
   $(&quot;.shi-content&quot;).html(content); 
   $(&quot;.shi-author&quot;).html(author);
   $(&quot;.shi-category&quot;).html(category);
   $(&quot;.shi-origin&quot;).html(origin);
  });
 }
&lt;/script&gt;
</code></pre>
<p></p>
因為我們設定了shi-content、shi-author、shi-category、shi-origin這四個元素，因此我們也需要在網頁中插入相對應的呼叫，只需要使用 class="shi-origin" (以此類推)。
<p>以下為放在<code>&lt;body&gt;...&lt;/body&gt;</code>的內容：</p>
<pre><code class="language-html">&lt;h1&gt;&lt;ins class=&quot;shi-origin&quot;&gt;標題&lt;/ins&gt;&lt;/h1&gt;
&lt;cite class=&quot;shi-author&quot;&gt;作者&lt;/cite&gt;
&lt;br&gt;
&lt;blockquote&gt;
&lt;div class=&quot;shi-content&quot;&gt;內文&lt;/div&gt;
&lt;/blockquote&gt;
分類：&lt;font class=&quot;shi-category&quot;&gt;&lt;/font&gt;

&lt;p&gt;
&lt;button onclick=&quot;javascript:nextshi();&quot;&gt;Random&lt;/button&gt; //使用按鈕來隨機產生
</code></pre>
<h1>範例效果</h1>
<ol>
<li>未按按鈕前<br>
<img src="https://Z1Nhouse.github.io//post-images/1577895935822.PNG" alt=""></li>
<li>隨機產生後<br>
<img src="https://Z1Nhouse.github.io//post-images/1577895939269.PNG" alt=""></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【資料結構】圖形結構(Graph)基礎篇(3) - 最短路徑(Shortest Paths)]]></title>
        <id>https://Z1Nhouse.github.io//post/W9lvX_AV-</id>
        <link href="https://Z1Nhouse.github.io//post/W9lvX_AV-">
        </link>
        <updated>2019-12-30T13:39:35.000Z</updated>
        <content type="html"><![CDATA[<p>勤奮編輯中....!</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【資料結構】圖形結構(Graph)基礎篇(2) - 擴張樹(Spanning Tree)]]></title>
        <id>https://Z1Nhouse.github.io//post/p0rM7JmKv</id>
        <link href="https://Z1Nhouse.github.io//post/p0rM7JmKv">
        </link>
        <updated>2019-12-30T13:13:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="擴張樹spanning-tree">✨擴張樹(Spanning Tree)</h2>
<p>擴張樹(Spanning Tree)又稱花費樹，一個圖形的擴張樹是以最少的邊來連結圖形中所有的頂點(且須避免循環)。</p>
<ol>
<li>一棵包含圖上所有頂點的樹，稱作該圖的擴張樹。</li>
<li>一張圖的擴張樹可能會有很多種。</li>
<li>完全連通圖才有擴張樹 (不連通時，則稱為擴張森林)。</li>
<li>擴張樹的權重為樹上每條邊的權重總和。</li>
</ol>
<p>假設今天有n個頂點的無向圖形擴張樹，則會有n-1個邊。<br>
使用BFS方式追蹤產生的擴張樹稱為寬度優先擴張樹；使用DFS追蹤產生的擴張樹則稱為深度優先擴張樹。</p>
<h2 id="花費最少擴張樹minimum-spanning-tree">✨花費最少擴張樹(Minimum Spanning Tree)</h2>
<p>一副<strong>連通加權無向圖</strong>中擁有最小成本(權重)的擴張樹就稱為花費最少擴張樹。<br>
那麼為何需要找到花費最少擴張樹？<br>
因為很多情境都可由圖形來表示，例如從台北到西班牙轉機的距離就可以以此找出花費最少的方法。</p>
<p>找出一個加權圖形中花費最少擴張樹可以利用以下三種演算法(當然不止這三種)：</p>
<ol>
<li>Kruskal's Algorithm</li>
<li>Prim's Algorithm</li>
<li>Sollin's Algorithm</li>
</ol>
<p>這三種演算法皆是greedy algorithm(貪婪法則)。</p>
<h3 id="kruskals-algorithm">🌸Kruskal's Algorithm</h3>
<p>這個演算法較容易實作，由Spanning tree中<strong>花費最少的邊</strong>出發，每一次都選擇目前尚未被選擇的最少花費的邊，且避免形成循環，直到邊的個數為n-1(頂點為n)即找出花費最少擴張樹。</p>
<p><img src="https://Z1Nhouse.github.io//post-images/1577711708165.gif" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1577711903994.gif" alt=""></p>
<h3 id="prims-algorithm">🌸Prim's Algorithm</h3>
<p>先從Spanning tree中找一個頂點V作為起始點，找出與V相連且還沒有被選取的頂點裡面加權值最小的邊，直到找到n-1個邊(頂點為n)。</p>
<p><img src="https://Z1Nhouse.github.io//post-images/1577711713650.gif" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1577711910898.gif" alt=""></p>
<h3 id="sollins-algorithm">🌸Sollin's Algorithm</h3>
<p>每次選擇花費最少的子圖，並且再選取花費較少的邊將這些子圖相連(不能造成循環)，直到邊數為n-1(頂點為n)停止。</p>
<figure data-type="image" tabindex="1"><img src="https://Z1Nhouse.github.io//post-images/1577712145202.gif" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【資料結構】圖形結構(Graph)基礎篇(1)]]></title>
        <id>https://Z1Nhouse.github.io//post/BFgV-T9ON</id>
        <link href="https://Z1Nhouse.github.io//post/BFgV-T9ON">
        </link>
        <updated>2019-12-24T12:35:04.000Z</updated>
        <summary type="html"><![CDATA[<p>起源為瑞士的數學家尤拉解決Koenigsberg bridge problem(七橋問題)。<br>
圖形結構提供了簡單的方式來描述一個問題、系統或狀況等。<br>
與樹狀結構的差異為，樹狀結構是描述節點與節點之間的層次關係。</p>
]]></summary>
        <content type="html"><![CDATA[<p>起源為瑞士的數學家尤拉解決Koenigsberg bridge problem(七橋問題)。<br>
圖形結構提供了簡單的方式來描述一個問題、系統或狀況等。<br>
與樹狀結構的差異為，樹狀結構是描述節點與節點之間的層次關係。</p>
<!-- more -->
<h2 id="定義與種類">📜定義與種類</h2>
<p>一個圖形是由頂點集合V與邊集合E所組成，數學上通常用G = (V,E)表示。</p>
<p>圖形結構具有以下特徵：</p>
<ol>
<li>基本上是由頂點(Vertices)與邊(Edges)兩個部分所構成。</li>
<li>有方向性稱為有向圖(Directed Graph)、無方向性稱為無向圖(Undirected Graph)。</li>
<li>圖形的特點之一為資料也可以儲存在個別<strong>邊</strong>上。邊上的資料可以表示從這個邊的一個頂點至另一個頂點的花費(cost)。這種成本存在邊上的圖形稱為｢網路」。</li>
</ol>
<p>下方為示意圖：<br>
<img src="https://Z1Nhouse.github.io//post-images/1577190922243.PNG" alt=""></p>
<p>依據線段(Edge)有沒有方向性可分為<strong>無向圖</strong>及<strong>有向圖</strong>：</p>
<ul>
<li>
<p><strong>無向圖(Undirected graph)</strong><br>
邊集合中的每一個邊都沒有方向性。</p>
</li>
<li>
<p><strong>有向圖(Directed graph)</strong><br>
邊集合中的每一個編都有方向性，以指向下一個頂點。</p>
</li>
</ul>
<p>此無向圖G1的點集合與邊集合為：<br>
<img src="https://Z1Nhouse.github.io//post-images/1577190934860.png" alt=""><br>
V(G1)={1,2,3,4,5,6}<br>
E(G1)={(1,2), (1,3),(2,4),(3,4),(3,5),(4,5),(4,6)}</p>
<p>此有向圖G2的點集合與邊集合為：<br>
<img src="https://Z1Nhouse.github.io//post-images/1577191098864.png" alt=""><br>
V(G2)={1,2,3,4}<br>
E(G2)={(1,2), (1,3),(3,2),(3,4),(4,3)}</p>
<p>樹也是一種圖，但是樹可以出現環、連通，而樹不行。<br>
注意，圖形不能有自我迴圈(self-loop)。</p>
<h3 id="圖形結構的用詞">💬圖形結構的用詞</h3>
<p>圖(1)<br>
<img src="https://Z1Nhouse.github.io//post-images/1577191098864.png" alt=""><br>
圖(2)<br>
<img src="https://Z1Nhouse.github.io//post-images/1577191142220.png" alt=""></p>
<ul>
<li><strong>頂點(Vertex)</strong>：也可稱為資料節點(Node)，例如圖(1)的1,2,3,4。</li>
<li><strong>邊(Edge)</strong>：每個頂點的連線就稱為邊。</li>
<li><strong>相鄰(Adjacent)</strong>：例如圖(2)的1,2相鄰。</li>
<li><strong>路徑(Path)</strong>：某個頂點到某個頂點的過程。</li>
<li><strong>連通(Connected)</strong>：在一&quot;無向圖&quot;中，任何成對頂點之間皆有路徑存在。<br>
<img src="https://Z1Nhouse.github.io//post-images/1577191912704.PNG" alt=""></li>
</ul>
<ol>
<li>
<p>強連通(Strongly connected)：<br>
在&quot;有向圖&quot;中，<strong>任何</strong>成對頂點之間皆有路徑可以相互到達對方。<br>
<img src="https://Z1Nhouse.github.io//post-images/1577192024532.PNG" alt=""></p>
</li>
<li>
<p>弱連通(Weakly connected)：<br>
在&quot;有向圖&quot;中，<strong>至少</strong>有兩個頂點無法以有向路徑相互到達對方。</p>
</li>
</ol>
<ul>
<li>
<p><strong>簡單路徑(Simple path)</strong>：路徑上除了起點和終點可以相同之外，其餘頂點均不相同。<br>
<img src="https://Z1Nhouse.github.io//post-images/1577191244570.png" alt=""></p>
</li>
<li>
<p><strong>循環(Cycle)</strong>：若有一條簡單路徑的起點頂點與終點頂點相同，則稱這條路徑為cycle。</p>
</li>
<li>
<p><strong>分支度(Degree)</strong>：(無向圖)為連接至該頂點的邊之個數。比如圖(2)，1的分支度為&quot;2&quot;，4的分支度為&quot;4&quot;。<br>
有向圖還會區分為外分支度(Outdegree)與內分支度(Indegree)。</p>
</li>
<li>
<p><strong>子圖(Subgraph)</strong>：圖中的某一部分。<br>
<img src="https://Z1Nhouse.github.io//post-images/1577191627812.PNG" alt=""></p>
</li>
<li>
<p><strong>完整圖(Complete Graph)</strong>：是一個擁有最多非重複邊線的圖：</p>
</li>
</ul>
<ol>
<li>無向圖：若圖具有n個頂點，則具有最多的非重複邊個數達<code>n(n-1)/2</code>時，此圖稱為完整圖。</li>
<li>有向圖：若圖具有n個頂點，則具有最多的非重複邊個數達<code>n(n-1)</code>時，此圖稱為完整圖。<br>
<img src="https://Z1Nhouse.github.io//post-images/1577191576654.gif" alt=""></li>
</ol>
<h2 id="表示方式">🔎表示方式</h2>
<p>常用的表示方式：相鄰矩陣(Adjacency Matrix)、相鄰串列(Adjacency List)</p>
<h3 id="相鄰矩陣adjacency-matrix">🎈相鄰矩陣(Adjacency Matrix)</h3>
<p>對無向圖而言，根據項點數n，宣告一個n×n的二維矩陣。<br>
矩陣中，每個1就代表該兩個項點有連線。<br>
<img src="https://Z1Nhouse.github.io//post-images/1577192189083.PNG" alt=""></p>
<ul>
<li>無向圖的相鄰矩陣必為對稱(Symmetric)，對角線皆為0，因為自己與自己本身無法相連(<code>A[1][1]、A[2][2]....A[i][j]</code>)其儲存空間為<code>n(n-1)/2</code>。</li>
<li>有向圖的相鄰矩陣不一定為對稱，但當有向圖為完整圖時也會是對稱矩陣。</li>
</ul>
<h3 id="相鄰串列adjacency-list">🎈相鄰串列(Adjacency List)</h3>
<p>有幾個頂點(n)就需要幾條相鄰串列與一個大小為n的一維陣列，其中A[i] 所存放的是頂點i 的相鄰串列，此串列中毎個Node皆記録著與頂點i 相鄰之其它頂點。</p>
<ol>
<li>
<p>無向<br>
<img src="https://Z1Nhouse.github.io//post-images/1577192594214.gif" alt=""></p>
</li>
<li>
<p>有向<br>
<img src="https://Z1Nhouse.github.io//post-images/1577192729326.gif" alt=""></p>
</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://Z1Nhouse.github.io//post-images/1577192986524.PNG" alt=""></figure>
<h2 id="圖形追蹤traverse-graph">📍圖形追蹤(Traverse Graph)</h2>
<p>圖形中的所有頂點都被拜訪到，且僅被拜訪到一次。<br>
分為DFS深先搜尋與BFS廣先搜尋。</p>
<h3 id="深先搜尋depth-first-search">📌<strong>深先搜尋(Depth First Search)</strong></h3>
<p>包含<strong>遞迴應用</strong>的概念，因此可利用<code>堆疊(Stack)</code>保存走訪過程中間所走過的點。</p>
<p>如同前序追蹤，先遇到的頂點就先探索，如果節點有子節點，首先對其進行探索。<br>
除非另有說明，否則通常從左到右。<br>
如果從任何已走訪過的頂點，都無法再走訪到一個尚未被走過的頂點時，則結束走訪。</p>
<figure data-type="image" tabindex="2"><img src="https://Z1Nhouse.github.io//post-images/1577193694728.png" alt=""></figure>
<p>PS.DFS之順序並不唯一除非規定“拜訪時，依Node編號由小到大拜訪”才會唯一。</p>
<p>我們可以利用DFS進行**拓撲排序(Topological Sort)**也可找到有向圖中的Strongly Connected Component(SCC)。</p>
<h3 id="廣先搜尋breadth-first-search">📌<strong>廣先搜尋(Breadth First Search)</strong></h3>
<p>BFS是廣義的層級探索(Level-Order Traversal)，將之從樹推廣至圖。<br>
BFS運作流程基本上與DFS差不多，但BFS是利用<code>佇列(Queue)</code>保存走訪過程中間所走過的點。</p>
<p>由起始頂點15 開始走訪。<br>
所有相鄰至15且尚未被拜訪過的頂點，都會在下個步驟裡一一被走訪。<br>
而相鄰至這些被走訪頂點且尚未走過的頂點，又將被一一走訪；重複上述，直到無頂點可被拜訪為止。<br>
<img src="https://Z1Nhouse.github.io//post-images/1577194220398.jpg" alt=""></p>
<h2 id="aov-networks與toplogical">🔸AOV Networks與Toplogical</h2>
<p>AOV全稱Activity On Vertex，假設G = &lt;V, E&gt;為一個&quot;有向圖&quot;，其中<strong>頂點</strong>表示工作(Activity)，<strong>線段</strong>表示工作執行之先後次序關係。<br>
<img src="https://Z1Nhouse.github.io//post-images/1577195363117.png" alt=""></p>
<p>應用: 求合理的工作執行順序，即：<strong>拓樸順序(Topological Order)</strong></p>
<p><strong>🔸拓樸順序(Topological Order)</strong></p>
<ol>
<li>找出一個無前導(內分支度為0)的頂點將此頂點輸出。</li>
<li>刪除此點及其線段。</li>
<li>直到所有頂點已輸出，或剩下的點皆有前導存在。</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://Z1Nhouse.github.io//post-images/1577196549261.png" alt=""></figure>
<ul>
<li>若AOV Network有cycle，則無Topological Order。(<code>∵無法決定誰先做</code>)</li>
<li>不具cycle的AOV Network，其Topological Order ≥1組。(<code>不一定唯一</code>)</li>
</ul>
<h2 id="aoe-networks">🔹AOE Networks</h2>
<p>AOE全稱Activity On Edge，在<code>有加權的有向圖</code>上以Edge表示工作(Activity)，Vertex表示事件(Event)，Edge上具有加權值，表示工作完成所需的時間。<strong>與AOV不同之處在於，AOV以Vertex表示工作，而AOE是以Edge表示工作。</strong></p>
<figure data-type="image" tabindex="4"><img src="https://Z1Nhouse.github.io//post-images/1577196821362.png" alt=""></figure>
<p><strong>完成此計畫所需之最少(最起碼)的工作時數?</strong><br>
求從<code>Start → End</code>事件之最長路徑長度即：求<code>Critical path (臨界路徑)</code>的長度。</p>
<p>上圖有可能的路徑為</p>
<ol>
<li>0→1→4→5→6 (持續時間=15)</li>
<li>0→1→2→5→6 (持續時間=16)</li>
<li>0→2→5→6 (持續時間=13)</li>
<li>0→2→3→5→6 (持續時間=20)</li>
<li>0→3→5→6 (持續時間=17)</li>
</ol>
<p>最長路徑的長度為20，因此有一條路徑為<code>Critical path(臨界路徑)</code>。</p>
<p>由於在AOE Networks中有些活動可以並列地進行，所以完成工程的最短時間是從開始點到完成點的最長路徑的長度（路徑上各活動持續時間之和）。路徑長度最長的路徑叫做<code>關鍵路徑</code>。</p>
<h3 id="最早開始最脕開始時間">最早開始/最脕開始時間</h3>
<p>在AOE網路上所有的活動皆有的時間，最晚開始時間指一活動在不影響整個計畫完成之下，最晚能夠開始進行的時間。</p>
<figure data-type="image" tabindex="5"><img src="https://Z1Nhouse.github.io//post-images/1577196821362.png" alt=""></figure>
<p>以上圖計算最早及最晚時間，結果如下：</p>
<figure data-type="image" tabindex="6"><img src="https://Z1Nhouse.github.io//post-images/1577367557250.PNG" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在Windows底下安裝Ruby On Rails 開發環境及建立專案]]></title>
        <id>https://Z1Nhouse.github.io//post/LgyMo5WnT</id>
        <link href="https://Z1Nhouse.github.io//post/LgyMo5WnT">
        </link>
        <updated>2019-12-16T15:55:59.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="事前準備">📌事前準備</h2>
<p>在安裝Rails之前需先安装：</p>
<ol>
<li><a href="https://www.ruby-lang.org/en/downloads">Ruby</a> 1.9.3 及以上版本。<br>
<strong>務必要先安裝Ruby啊...沒有Ruby何必學Rails...！</strong></li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<h2 id="事前準備">📌事前準備</h2>
<p>在安裝Rails之前需先安装：</p>
<ol>
<li><a href="https://www.ruby-lang.org/en/downloads">Ruby</a> 1.9.3 及以上版本。<br>
<strong>務必要先安裝Ruby啊...沒有Ruby何必學Rails...！</strong></li>
</ol>
<!-- more -->
<ol start="2">
<li><a href="https://rubygems.org/">RubyGems</a> 一個伴隨 Ruby 1.9+ 安裝的套件管理程式。<br>
如果想學習更多有關於 RubyGems，請參考 <a href="http://guides.rubygems.org/">RubyGems 指南</a>。</li>
<li><a href="https://www.sqlite.org/">SQLite3資料庫</a>。<br>
可以在官網下載或者打開命令提示字元輸入<code>gem install sqlite3</code>安裝。</li>
<li><a href="https://nodejs.org/en/download/">NodeJS</a>。</li>
<li><a href="https://yarnpkg.com/en/docs/install#windows-stable">Yarn</a>。</li>
<li><a href="https://git-scm.com/downloads">Git</a>。<br>
NodeJS、Yarn、Git都是下載完安裝即可，這邊就不多提了。</li>
</ol>
<p>Rails是使用Ruby開發的Web框架，所以在學習Rails之前建議先擁有Ruby的相關經驗。<br>
至於渠道也不需要我多提了吧，Google一下就能找到了，或者你也可以在<a href="https://www.ruby-lang.org/zh_tw/documentation/">Ruby的官方網站</a>查看文檔。</p>
<hr>
<h2 id="rails-開發哲學">📔Rails 開發哲學</h2>
<ol>
<li>不要重複你自己<br>
DRY 是一個軟體工程的開發原則，“系統中每個功能的構思都必須要有單一、明確且讓人認同的表達方式”儘量避免一再重複的相同資訊，所寫的程式才容易維護、有擴展性且不容易出現 Bug。</li>
<li>約定優於配置<br>
Rails 不希望你浪費太多時間無止境的配置設定上，而是直接把最好的一些 Web 開發方式設為預設值，讓你熟悉之後就可以上手了。</li>
</ol>
<hr>
<h2 id="安裝railsinstaller">🔧安裝RailsInstaller</h2>
<p><strong>因為我是Win10，這邊示範使用<a href="http://railsinstaller.org/en">RailsInstaller</a>安裝Rails。<br>
Mac系統也可以選擇使用<a href="https://github.com/tokaido/tokaidoapp">Tokaido</a>。</strong></p>
<p>RailsInstaller3.4.0包含：</p>
<ul>
<li>Ruby 2.3.3</li>
<li>Rails 5.1</li>
<li>Bundler</li>
<li>Git</li>
<li>Sqlite</li>
<li>TinyTDS</li>
<li>SQL Server Support</li>
<li>DevKit</li>
</ul>
<p>安裝過程省略，但是要特別注意的是<strong>確認是否有勾選「Install Git」版本管理及「Add executables for Ruby, DevKit and Git (if checked above) to the PATH」</strong>，如果你沒有很熟悉的話就是都打勾安裝就好。<strong>但如果已經安裝過Git可以取消勾選Install Git。</strong><br>
<img src="https://Z1Nhouse.github.io//post-images/1576512159679.png" alt=""></p>
<p>安裝完之後打開命令提示字元(cmd)輸入命令確認一下：</p>
<pre><code>ruby -v
sqlite3 --version
</code></pre>
<p>若都有正確顯示版本就可以開始安裝Rails了。<br>
PS.<strong>sqlite3沒安裝的話要記得安裝哦，不知道怎麼安裝請看事前準備第三條</strong><br>
<img src="https://Z1Nhouse.github.io//post-images/1576512394489.PNG" alt=""></p>
<h3 id="安裝rails">🔧安裝Rails</h3>
<p>輸入命令<code>gem install rails</code></p>
<p><img src="https://Z1Nhouse.github.io//post-images/1576514385760.PNG" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1576512502197.PNG" alt=""></p>
<p>沒有跳出任何錯誤信息，安裝完之後輸入命令<code>rails --version</code><br>
<img src="https://Z1Nhouse.github.io//post-images/1576512549924.PNG" alt=""><br>
確認版本訊息是否正確，以確保正確安裝。</p>
<hr>
<h2 id="建立專案">📝建立專案</h2>
<p>進入專案位置<code>cd C:\sites</code> (或者你想在任何位置新建專案)輸入命令：</p>
<pre><code>rails new demo
</code></pre>
<p>demo可以改為你自訂的專案名稱。<br>
<img src="https://Z1Nhouse.github.io//post-images/1576512773668.PNG" alt=""></p>
<p>新建成功的話此時<code>C:\sites</code>底下會多出一個demo目錄，這個目錄中有許多自動產生的檔案和資料夾，這些是構成 Rails 應用程式的重要元素。<br>
<img src="https://Z1Nhouse.github.io//post-images/1576512845646.PNG" alt=""><br>
下方為自動產生的目錄、檔案以及用途：<br>
<img src="https://Z1Nhouse.github.io//post-images/1576512991038.png" alt=""></p>
<h3 id="啟動rails伺服器">💻啟動Rails伺服器</h3>
<p>切換到demo目錄裡，輸入命令<code>rails s</code>或者<code>rails server</code>啟動 Rails 伺服器。<br>
<img src="https://Z1Nhouse.github.io//post-images/1576513119128.PNG" alt=""></p>
<p>啟動成功之後打開瀏覽器輸入<code>127.0.0.1:3000</code>便會看到 Rails 的預設頁面，你可以看見你的Rails以及Ruby版本。<br>
<img src="https://Z1Nhouse.github.io//post-images/1576513250787.PNG" alt=""></p>
<p>如想停止 WEB 伺服器，請在命令視窗按下 Ctrl+C 跳回命令提示字元就可以終止服務。</p>
<hr>
那麼以上就是在Windows系統中安裝Rails環境以及建立專案的完整過程，如果在安裝Rails的途中有遇到任何困難，可以先參考這篇文章--><a href="https://mycodeissuesandfixes.blogspot.com/2019/02/ruby-on-rails-issue-about-sqlite-3-gem.html">Ruby on Rails issue about Sqlite3 Gem</a>，可能大部分都是這個問題。
如果是其他的問題，可以Google一下自行搜索解決呦。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[絕對可用，威力導演18破解版！]]></title>
        <id>https://Z1Nhouse.github.io//post/2ih2aeMZB</id>
        <link href="https://Z1Nhouse.github.io//post/2ih2aeMZB">
        </link>
        <updated>2019-12-14T13:19:14.000Z</updated>
        <summary type="html"><![CDATA[<p>於2019/12/14測試可用。</p>
]]></summary>
        <content type="html"><![CDATA[<p>於2019/12/14測試可用。</p>
<!-- more -->
<p>下載：<a href="https://mega.nz/#!M91kTI5B!-LaoHCQ158qfhpX993FoZISX35qj0eS_WygfFuGh5ms">MEGA</a></p>
<h2 id="安裝及破解步驟">安裝及破解步驟</h2>
<ol>
<li>雙擊已經內置了破解補丁的安裝包，開始安裝<br>
<img src="https://Z1Nhouse.github.io//post-images/1576329693892.PNG" alt=""></li>
<li>此處省略安裝步驟<br>
<img src="https://Z1Nhouse.github.io//post-images/1576329703029.PNG" alt=""></li>
<li>安裝完畢請直接關閉，不要啟動<br>
<img src="https://Z1Nhouse.github.io//post-images/1576329731360.PNG" alt=""></li>
<li>打開<code>C:/Windows/System32/drivers/etc</code>文件夾，將裡頭的<code>hosts</code>文件複製到桌面。<br>
<img src="https://Z1Nhouse.github.io//post-images/1576329960161.PNG" alt=""></li>
<li>用記事本打開，在最下方加上以下兩行，以屏蔽威力導演連線驗證。</li>
</ol>
<pre><code>127.0.0.1 cap.cyberlink.com 
127.0.0.1 activation.cyberlink.com 
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://Z1Nhouse.github.io//post-images/1576329964188.PNG" alt=""></figure>
<blockquote>
<p>PS.若是無法修改，看看是否hosts為&quot;唯獨&quot;模式，如果是把勾取消掉即可。<br>
<img src="https://Z1Nhouse.github.io//post-images/1576330021505.PNG" alt=""></p>
</blockquote>
<ol start="6">
<li>改完之後將hosts複製貼上到<code>C:/Windows/System32/drivers/etc</code>文件夾覆蓋。</li>
<li>點擊 Reg Patch.reg 文件導入註冊表。<br>
<img src="https://Z1Nhouse.github.io//post-images/1576330101623.PNG" alt=""></li>
<li>打開威力導演「不，謝謝」、「現在不要」<br>
<img src="https://Z1Nhouse.github.io//post-images/1576330157315.PNG" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1576330163818.PNG" alt=""></li>
<li>隨便找一個素材拖到時間軸上然後按&quot;輸出檔案&quot;。<br>
<img src="https://Z1Nhouse.github.io//post-images/1576330459045.PNG" alt=""></li>
<li>選擇H.265 HEVC輸出會跳出聯網提示框，點擊&quot;我目前沒有Internet連接&quot;<br>
<img src="https://Z1Nhouse.github.io//post-images/1576330296430.PNG" alt=""></li>
<li>隨意輸入一串數字點擊&quot;確定&quot;即可完成驗證<br>
<img src="https://Z1Nhouse.github.io//post-images/1576330347821.PNG" alt=""></li>
</ol>
<p>至此，威力導演18已經破解完畢，可以正常使用了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[親測可用，After Effects CC 2017 14.0 破解免安装版]]></title>
        <id>https://Z1Nhouse.github.io//post/g2rnGSLkr</id>
        <link href="https://Z1Nhouse.github.io//post/g2rnGSLkr">
        </link>
        <updated>2019-12-14T13:12:14.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>原網址：<a href="https://www.pcsoft.com.cn/soft/150122.html">https://www.pcsoft.com.cn/soft/150122.html</a><br>
於2019/12/14測試過可正常使用(Win10)。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>原網址：<a href="https://www.pcsoft.com.cn/soft/150122.html">https://www.pcsoft.com.cn/soft/150122.html</a><br>
於2019/12/14測試過可正常使用(Win10)。</p>
</blockquote>
<!-- more -->
<ul>
<li>軟體大小：861.64MB</li>
<li>軟體介面為英文</li>
<li>應用平台：WinXP,Win7,WinAll</li>
<li>下載鏈結：<a href="http://forspeed.pcsoft.com.cn/download/pc/AdobeAfterEffectsCC_2017.zip">點我</a>、備用載點</li>
</ul>
<h2 id="安裝教學">安裝教學</h2>
<ol>
<li>下載完之後解壓縮至任意位置。</li>
<li>打開&quot;Support Files&quot;直接點擊&quot;AfterFX.exe&quot;即可使用。<br>
<img src="https://Z1Nhouse.github.io//post-images/1576329369843.PNG" alt=""></li>
<li>開啟可能會有錯誤提示框且沒有任何內容，點擊提示框右下角可以略過。<br>
<img src="https://Z1Nhouse.github.io//post-images/1576329426347.PNG" alt=""></li>
<li>免安裝和激活就可以馬上使用了！<br>
<img src="https://Z1Nhouse.github.io//post-images/1576329458517.PNG" alt=""></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初學者也能快速上手的Python爬蟲(3) - 抓取Yahoo奇摩新聞首頁標題與連結]]></title>
        <id>https://Z1Nhouse.github.io//post/Ks78sAGhX</id>
        <link href="https://Z1Nhouse.github.io//post/Ks78sAGhX">
        </link>
        <updated>2019-12-11T14:16:57.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇文章適用於對python以及html語法略懂皮毛的初學者，若什麼都不瞭解建議邊學邊google，畢竟現代科技非常發達嘛。<br>
上一篇：<a href="https://z1nhouse.github.io/post/3qgNl3ySw/">初學者也能快速上手的Python爬蟲(2) - 安裝兩個重要的Package</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇文章適用於對python以及html語法略懂皮毛的初學者，若什麼都不瞭解建議邊學邊google，畢竟現代科技非常發達嘛。<br>
上一篇：<a href="https://z1nhouse.github.io/post/3qgNl3ySw/">初學者也能快速上手的Python爬蟲(2) - 安裝兩個重要的Package</a></p>
<!-- more -->
<h2 id="解析網頁內容及標籤">解析網頁內容及標籤</h2>
<p>我們今天學習的目標是抓取<a href="https://tw.yahoo.com/">Yahoo奇摩</a>首頁的新聞標題。<br>
<img src="https://Z1Nhouse.github.io//post-images/1576074601634.PNG" alt=""></p>
<p>並且我希望呈現下方的形式：</p>
<pre><code>新聞標題：xxxxxxx
新聞地址：http://........
</code></pre>
<p>首先，你可以透過<code>Ctrl+Shift+I</code>或者<code>F12</code>打開&quot;開發人員工具&quot;，並且點擊選取工具指向想要抓取的資料位置，就會自動跳到該資料的程式碼位置。<br>
<img src="https://Z1Nhouse.github.io//post-images/1576074233704.png" alt=""><br>
注：建議使用Google Chrome或者Fire Fox瀏覽器。</p>
<p>大致看一下每個標題之間標籤的共通點，例如這篇新聞標題是以連結標籤包裹住的，class名稱為<code>D-b Abu-C-b Fw-b Mb-6 Ell Fz-m Cur-p story-title</code>，若是你仔細觀察，可以發現每一個新聞標題超連結的class都是一樣的，我們可以只使用其中的一部分<code>story-title</code>或者全部使用皆可。</p>
<pre><code>&lt;a href=&quot;https://bit.ly/2rDxQ5R&quot; class=&quot;D-b Abu-C-b Fw-b Mb-6 Ell Fz-m Cur-p 
story-title&quot;data-ylk=&quot;rspns:nav;t1:a3;t2:td;t3:nav;sec:td-fea;elm:hdln;elmt:ct;itc:0;
cpos:3;pkgt:1;ccode:p_zh_hant_tw_lm_or1;aid:id-6232;
g:da398d27-7f67-354b-a8da-a233efb81343;cat:t5;subsec:t5;ct:1;ad:0;slk:賈靜雯也掃貨？櫃姐卻
曝1憾;&quot; data-rapid_p=&quot;74&quot; data-v9y=&quot;1&quot; id=&quot;yui_3_12_0_3_1576066112353_2420&quot;&gt;&lt;span 
class=&quot;Va-tt&quot; id=&quot;yui_3_12_0_3_1576066112353_2419&quot;&gt;賈靜雯也掃貨？櫃姐卻曝1憾&lt;/span&gt;&lt;/a&gt;
</code></pre>
<h2 id="抓取需要的資料">抓取需要的資料</h2>
<ol>
<li>在最開始需要先import requests和BeautifulSoup4。</li>
</ol>
<pre><code>import requests
from bs4 import BeautifulSoup
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://Z1Nhouse.github.io//post-images/1576073982921.PNG" alt=""></figure>
<ol start="2">
<li>接著使用 GET 方式下載普通網頁，並將網頁內容儲存在res變數中，接著輸入<code>print(res.status_code)</code>來確認伺服器回應的狀態碼，若顯示<code>200</code>代表OK沒問題。</li>
</ol>
<pre><code>res = requests.get(&quot;https://tw.yahoo.com/&quot;)
# 確認伺服器回應的狀態碼,可不寫
print(res.status_code)
</code></pre>
<p><img src="https://Z1Nhouse.github.io//post-images/1576074770071.PNG" alt=""><br>
注：<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81">HTTP狀態碼</a></p>
<ol start="3">
<li>輸入<code>print(res.text)</code>可以印出網頁的原始碼，你可以在這研究一下標題們的標籤之間的共同點。<br>
<img src="https://Z1Nhouse.github.io//post-images/1576074895791.PNG" alt=""><br>
你也可以透過BeautifulSoup提取網頁原始碼再印出。</li>
</ol>
<pre><code>soup = BeautifulSoup(res.text)
print(soup)
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://Z1Nhouse.github.io//post-images/1576075006487.PNG" alt=""></figure>
<ol start="4">
<li>以 Beautiful Soup 解析 HTML 程式碼，並儲存在soup變數中。</li>
</ol>
<pre><code>#Python標準庫
soup = BeautifulSoup(res.text, 'html.parser')
</code></pre>
<ol start="5">
<li>我們可以利用<code>find_all</code> 找出所有特定的 HTML 標籤節點。</li>
</ol>
<pre><code>data = soup.find_all(&quot;標籤&quot;, &quot;class&quot;)
</code></pre>
<p>回憶一下我們剛剛是不是在yahoo奇摩首頁找到了新聞的標籤及class？<br>
<img src="https://Z1Nhouse.github.io//post-images/1576075576964.PNG" alt=""></p>
<p>因此我們可以找到class為<code>story-title</code>的a標籤，並將之存在data變數當中。</p>
<pre><code>data = soup.find_all(&quot;a&quot;, &quot;story-title&quot;)
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://Z1Nhouse.github.io//post-images/1576075735035.PNG" alt=""></figure>
<ol start="6">
<li>以 Python 的迴圈來依序輸出每個超連結的文字以及使用get來取得class為<code>story-title</code>的a標籤中的<code>href</code>內容：</li>
</ol>
<pre><code>for s in data:
    print(&quot;新聞標題：&quot; + s.text)
    print(&quot;新聞地址：&quot; + s.get(&quot;href&quot;))
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://Z1Nhouse.github.io//post-images/1576076216395.png" alt=""></figure>
<p>至此，本節課的目標達成啦！但現在僅僅只是沾上爬蟲的邊，未來還有許多要學習呢！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初學者也能快速上手的Python爬蟲(2) - 安裝兩個重要的Package]]></title>
        <id>https://Z1Nhouse.github.io//post/3qgNl3ySw</id>
        <link href="https://Z1Nhouse.github.io//post/3qgNl3ySw">
        </link>
        <updated>2019-12-11T13:53:54.000Z</updated>
        <summary type="html"><![CDATA[<p>上一篇：<a href="https://z1nhouse.github.io/post/lh0yq_CsU/">初學者也能快速上手的Python爬蟲(1) - Anaconda安裝與Jupyter Notebook使用</a></p>
<p>今天會需要用到兩個package：</p>
<ul>
<li>Requests</li>
<li>BeautifulSoup</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p>上一篇：<a href="https://z1nhouse.github.io/post/lh0yq_CsU/">初學者也能快速上手的Python爬蟲(1) - Anaconda安裝與Jupyter Notebook使用</a></p>
<p>今天會需要用到兩個package：</p>
<ul>
<li>Requests</li>
<li>BeautifulSoup</li>
</ul>
<!-- more -->
<h2 id="requests">Requests</h2>
<p><img src="https://Z1Nhouse.github.io//post-images/1576073717730.png" alt=""><br>
如果想要使用 Python 來下載網頁上的資料，最基本的作法就是以 requests 模組建立適當的 HTTP 請求，透過 HTTP 請求從網頁伺服器下載指定的資料。</p>
<p>Requests 是以 PEP 20 的箴言為中心開發的</p>
<ul>
<li>Beautiful is better than ugly.(美麗優於醜陋)</li>
<li>Explicit is better than implicit.(直白優於含蓄)</li>
<li>Simple is better than complex.(簡單優於復雜)</li>
<li>Complex is better than complicated.(複雜優於繁瑣)</li>
<li>Readability counts.(可讀性很重要)</li>
</ul>
<h3 id="功能特性">功能特性</h3>
<p>Requests 完全滿足今日 web 的需求。</p>
<ul>
<li>Keep-Alive &amp; 連接池</li>
<li>國際化域名和 URL</li>
<li>帶持久 Cookie 的會話</li>
<li>瀏覽器式的 SSL 認證</li>
<li>自動內容解碼</li>
<li>基本/摘要式的身份認證</li>
<li>優雅的 key/value Cookie</li>
<li>自動解壓</li>
<li>Unicode 響應體</li>
<li>HTTP(S) 代理支持</li>
<li>文件分塊上傳</li>
<li>流下載</li>
<li>連接超時</li>
<li>分塊請求</li>
<li>支持 .netrc</li>
</ul>
<h3 id="安裝方法">安裝方法</h3>
<p>安裝及使用教程<a href="https://2.python-requests.org//zh_CN/latest/user/install.html#install">官方網站</a>也有詳細的說明，這邊就簡單提一下。</p>
<p>你只需要打開終端運行指令即可安裝，例如在Jupyter Notebook的首頁找到<code>New - Terminal</code>打開終端，透過在終端輸入指令來安裝requests：</p>
<pre><code>pip install requests
</code></pre>
<p><img src="https://Z1Nhouse.github.io//post-images/1576072544945.png" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1576072815665.PNG" alt=""></p>
<h3 id="引入模組方法">引入模組方法</h3>
<pre><code># 引入 Requests 模組
import requests
</code></pre>
<h2 id="beautiful-soup">Beautiful Soup</h2>
<p><img src="https://Z1Nhouse.github.io//post-images/1576073722370.png" alt=""><br>
Beautiful Soup 是一個可以從HTML或XML文件中提取數據的Python庫。</p>
<h3 id="安裝方法-2">安裝方法</h3>
<p>同requests的安裝方法。<br>
<img src="https://Z1Nhouse.github.io//post-images/1576073463533.PNG" alt=""></p>
<h3 id="引入模組方法-2">引入模組方法</h3>
<pre><code># 引入 Beautiful Soup 模組
from bs4 import BeautifulSoup
</code></pre>
<p>更多使用方法可以參閱<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/#">官方文檔</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初學者也能快速上手的Python爬蟲(1) - Anaconda安裝與Jupyter Notebook使用]]></title>
        <id>https://Z1Nhouse.github.io//post/lh0yq_CsU</id>
        <link href="https://Z1Nhouse.github.io//post/lh0yq_CsU">
        </link>
        <updated>2019-12-11T12:46:54.000Z</updated>
        <summary type="html"><![CDATA[<p>Anaconda是目前最受歡迎的Python數據科學(Data Science)平台。<br>
超過1200萬人使用Anaconda發行版本，並且Anaconda擁有超過1400個適用於Windows、Linux和MacOS的數據科學分析的package。</p>
<p><strong>Anaconda Navigator包含如下應用：</strong><br>
JupyterLab<br>
Jupyter Notebook <strong>#我們需要使用到它</strong><br>
QtConsole<br>
Spyder<br>
Glueviz<br>
Orange<br>
Rstudio<br>
Visual Studio Code</p>
]]></summary>
        <content type="html"><![CDATA[<p>Anaconda是目前最受歡迎的Python數據科學(Data Science)平台。<br>
超過1200萬人使用Anaconda發行版本，並且Anaconda擁有超過1400個適用於Windows、Linux和MacOS的數據科學分析的package。</p>
<p><strong>Anaconda Navigator包含如下應用：</strong><br>
JupyterLab<br>
Jupyter Notebook <strong>#我們需要使用到它</strong><br>
QtConsole<br>
Spyder<br>
Glueviz<br>
Orange<br>
Rstudio<br>
Visual Studio Code</p>
<!-- more -->
<h2 id="安裝anaconda">安裝Anaconda</h2>
<ul>
<li><strong>下載<a href="https://www.anaconda.com/distribution/#download-section">Anaconda installer</a></strong><br>
根據作業系統與位元挑選合適的版本下載(有Windows、macOS與Linux)。</li>
</ul>
<p>安裝過程中需要注意的是這個步驟，建議<strong>不要</strong>勾選<code>Add Anaconda to my PATH environment variable</code>，因為這可能會干擾其他軟件。你可以通過從“開始”菜單打開Anaconda Navigator或Anaconda Prompt來使用Anaconda軟件。</p>
<figure data-type="image" tabindex="1"><img src="https://docs.anaconda.com/_images/win-install-options.png" alt=""></figure>
<h3 id="驗證安裝">驗證安裝</h3>
<p>安裝完成之後，Windows系統可以打開Anaconda Navigator，若可以正常開啟代表你已經成功安裝Anaconda。</p>
<ul>
<li>單擊開始，搜索或從菜單中選擇<code>Anaconda Navigator</code>。<br>
<img src="https://docs.anaconda.com/_images/win-navigator.png" alt=""></li>
</ul>
<p>或者你也可以通過Anaconda Prompt使用conda來驗證安裝。</p>
<ul>
<li>單擊開始，搜索或從菜單中選擇<code>Anaconda Prompt</code>。輸入以下指令：</li>
</ul>
<pre><code>conda -V
conda env list
</code></pre>
<p><img src="https://docs.anaconda.com/_images/win-anaconda-prompt.png" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1576069480581.PNG" alt=""><br>
如果Anaconda已安裝並正在運行，它將顯示conda的版本以及預設的虛擬環境。</p>
<p>如果直到現在你還是不知道該如何安裝，可以參考<a href="https://docs.anaconda.com/anaconda/install/windows/">官方的說明文檔</a>。</p>
<ul>
<li>macOS的安裝方法見官方<a href="https://docs.anaconda.com/anaconda/install/">Installing on macOS</a></li>
<li>Linux的安裝方法見官方<a href="https://docs.anaconda.com/anaconda/install/linux/">Installing on Linux</a></li>
</ul>
<h2 id="啟動jupyter-notebook">啟動Jupyter Notebook</h2>
<p><img src="https://Z1Nhouse.github.io//post-images/1576070359020.png" alt=""><br>
Jupyter Notebook舊稱IPython notebook，是一個介於IDE和Editor之間的寫code工具。<br>
最大的特性是可以逐行執行且做到資料視覺化，可以輸出成html5遷入到任何網頁或者blog，或是用notebook的形式分享，因此被許多人喜愛。<br>
支援多種主流直譯語言 ex:Python、R、Julia。</p>
<p>你有三種方式可以啟動Jupyter Notebook：</p>
<ol>
<li>
<p>開啟Anaconda Navigator後在Home頁面啟動Jupyter Notebook。<br>
<img src="https://Z1Nhouse.github.io//post-images/1576070329381.PNG" alt=""></p>
</li>
<li>
<p>打開<code>Anaconda Prompt</code>輸入<code>Jupyter Notebook</code>指令啟動。<br>
<img src="https://Z1Nhouse.github.io//post-images/1576070613551.PNG" alt=""></p>
</li>
<li>
<p>直接在&quot;開始&quot;菜單中找到<code>Jupyter Notebook</code><br>
<img src="https://Z1Nhouse.github.io//post-images/1576070980393.png" alt=""></p>
</li>
</ol>
<h2 id="使用jupyter-notebook">使用Jupyter Notebook</h2>
<p>Jupyer Notebook會透過瀏覽器來啟動(預設是localhost:8890)，你可以在右側New一個Python3的Notebook。<br>
<img src="https://Z1Nhouse.github.io//post-images/1576070672292.PNG" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1576071172920.png" alt=""></p>
<h3 id="介面介紹">介面介紹</h3>
<ul>
<li>
<p>將滑鼠移到檔名(預設為Untitled)單擊即可修改。<br>
<img src="https://Z1Nhouse.github.io//post-images/1576071604899.png" alt=""></p>
</li>
<li>
<p>Jupyter裡輸入程式碼的區塊叫做Cell，每一個Cell都可以單獨執行。<br>
<img src="https://Z1Nhouse.github.io//post-images/1576072014908.PNG" alt=""></p>
</li>
<li>
<p>你可以點擊小鍵盤查看Jupyter Notebook的一些快捷鍵。<br>
<img src="https://Z1Nhouse.github.io//post-images/1576072139646.png" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1576072137023.png" alt=""><br>
<strong>在選中cell時</strong></p>
</li>
</ul>
<ol>
<li>按下<code>x</code>：刪除當前選擇的cell</li>
<li>按下<code>a</code>：在當前選擇的上方新增一個cell</li>
<li>按下<code>b</code>：在當前選擇的下方新增一個cell</li>
<li>按下<code>Shift-Enter</code>：執行當前的cell並且選到下一個cell</li>
<li>按下<code>Ctrl-Enter</code>：執行當前cell</li>
</ol>
<ul>
<li>你甚至可以在工具列上修改Cell的類型，有Code、Markdown、Raw NBConvert、Heading可選擇。<br>
<img src="https://Z1Nhouse.github.io//post-images/1576071928351.png" alt=""></li>
</ul>
<p>基本操作以及一些玩法Google一下都有大把資料，甚至官方也有很詳細的說明，在這邊就不細講了。</p>
<p>延伸：<a href="http://opus.konghy.cn/ipynb/jupyter-notebook-keyboard-shortcut.html">Jupyter NoteBook 的快捷键使用指南</a></p>
]]></content>
    </entry>
</feed>