<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>【資料結構】平衡搜索樹 - 紅黑樹、B樹(2-3,2-3-4樹)、B+樹 | Z1N&#39;s house</title>
<meta name="description" content="System.out.print("Welcome to Z1N's house！");" />
<link rel="shortcut icon" href="https://Z1Nhouse.github.io//favicon.ico?v=1584879982540">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://Z1Nhouse.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://Z1Nhouse.github.io/">
  <img class="avatar" src="https://Z1Nhouse.github.io//images/avatar.png?v=1584879982540" alt="">
  </a>
  <h1 class="site-title">
    Z1N&#39;s house
  </h1>
  <p class="site-description">
    System.out.print("Welcome to Z1N's house！");
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首頁
        </a>
      
    
      
        <a href="/archives" class="menu">
          歸檔
        </a>
      
    
      
        <a href="/tags" class="menu">
          標籤
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/Z1Nhouse" target="_blank">
          <i class="fab fa-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              【資料結構】平衡搜索樹 - 紅黑樹、B樹(2-3,2-3-4樹)、B+樹
            </h2>
            <div class="post-info">
              <span>
                2019-12-08
              </span>
              <span>
                10 min read
              </span>
              
                <a href="https://Z1Nhouse.github.io//tag/kIcUV8jTk" class="post-tag">
                  # B樹
                </a>
              
                <a href="https://Z1Nhouse.github.io//tag/QsaVuSwBl_" class="post-tag">
                  # B+樹
                </a>
              
                <a href="https://Z1Nhouse.github.io//tag/pko_REMGZy" class="post-tag">
                  # 資料結構
                </a>
              
                <a href="https://Z1Nhouse.github.io//tag/6KnFtkOxpu" class="post-tag">
                  # 紅黑樹
                </a>
              
                <a href="https://Z1Nhouse.github.io//tag/VshjHIcuPM" class="post-tag">
                  # 平衡搜索樹
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://Z1Nhouse.github.io//post-images/5lQAWUQWk.jpg" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>2-3樹與2-3-4樹為B樹的特例，所以特別拿出來細講。<br>
今天主要講解的內容包括：2-3樹、2-3-4樹、紅黑樹、B樹、B+樹。</p>
<!-- more -->
<h2 id="何謂平衡搜索樹">何謂「平衡搜索樹」？</h2>
<p>平衡搜索樹常見的有：<strong>AVL、紅黑樹、B樹(2-3與2-3-4樹都是B樹的特例)</strong></p>
<blockquote>
<p>平衡樹的定義：若非空樹，則必須滿足父節點的左子樹與右子樹高度差絕對值不大於1。<br>
這其中，AVL、紅黑樹皆屬於平衡二元搜索樹。</p>
</blockquote>
<p><strong>※平衡搜索樹（Balanced Search Tree）新增、刪除及搜索的時間複雜度皆為O(logn)</strong><br>
不同平衡搜索樹的高度(height)：</p>
<ul>
<li>AVL樹：高度≦logn</li>
<li>紅黑樹：高度≦2logn</li>
<li>2-3樹：高度≦logn</li>
<li>2-3-4樹：高度≦logn</li>
</ul>
<h2 id="專業術語">專業術語</h2>
<ul>
<li>節點(node)：用以代表資料(data)、狀態(state)。</li>
<li>樹根(root)：樹中最上層的節點，也是唯一一個父節點為null的節點。</li>
<li>子(Child)節點：一個節點的下一層節點。</li>
<li>子樹(subtree)：去掉根節點，其餘的節點可分割成任意個數互斥的集合，每一個集合也都符合樹的定義。</li>
<li>葉節點(leaf)：沒有child/subtree的節點。</li>
<li>分支(degree)：一個node擁有的子樹個樹。</li>
<li>階度(level)：以根節點的階度為1，其餘節點的階度為其父節點的階度+1。</li>
<li>高度(height)：此樹的最高階度。</li>
<li>siblings：擁有相同父節點的節點們，為兄弟節點。</li>
</ul>
<p>常見到有人說這是3階,4階的樹，這裡的3階指的是一個節點最多可以擁有三個子節點，4階則是指一個節點最多可以擁有四個子節點。</p>
<h2 id="2-3樹">2-3樹</h2>
<p>為何會叫2-3樹？原因為每個節點可以有2或3個子節點。</p>
<ol>
<li>滿足二元搜索樹的基本性質—左小右大，但不是二元樹(因為最多可以擁有三個子節點)。</li>
<li>節點可以放1或2個元素(1個元素時有2個孩子；2個元素時有3個孩子)</li>
<li>是一棵絕對平衡的樹(左右子樹高度一定相同，所有葉節點皆在同一level)</li>
</ol>
<p>當今天有2個元素(b,c)3個子節點時，左子節點≦b ; b&lt;中子節點≦c ; c&lt;右子節點<br>
如下圖所示<br>
<img src="https://Z1Nhouse.github.io//post-images/1575798693292.PNG" alt=""></p>
<h3 id="2-3樹的元素新增">2-3樹的元素新增</h3>
<p>假設今天有一筆資料<code>{53,23,77,45,11,2,44,77,93,26,32,16,87,11}</code><br>
按照搜索樹的性質依序加入資料，下方為新增的步驟<br>
<img src="https://Z1Nhouse.github.io//post-images/1575798934769.PNG" alt=""><br>
當輸入到77時，一個節點有3個元素，此時需要進行平衡。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575798939021.PNG" alt=""><br>
將53(大小位於中間的元素)往上提變成根節點，左子節點為23，右子節點為77。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575798995848.PNG" alt=""><br>
接著輸入45,11，當輸入到11時左子樹又有三個元素，因此需要再平衡。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575799165863.PNG" alt=""><br>
將23往上提，11與45分別拆成左、中子節點。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575799189813.PNG" alt=""><br>
接著輸入2,44,77。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575799298976.PNG" alt=""><br>
再輸入93時，右子樹的元素為3個，需要再次平衡，將77往上提，如此一來根節點變成3個元素，因此將53再往上提一層，左子樹為23右子樹為77。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575799452952.PNG" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1575799456176.PNG" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1575799458271.PNG" alt=""><br>
接著輸入26，一樣需要平衡。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575799568254.PNG" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1575799571173.PNG" alt=""><br>
輸入32。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575799681696.PNG" alt=""><br>
輸入16，進行平衡。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575799730864.PNG" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1575799767051.PNG" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1575799769563.PNG" alt=""><br>
最後輸入87,11無須平衡，完成。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575799822760.PNG" alt=""></p>
<h3 id="2-3樹的元素刪除">2-3樹的元素刪除</h3>
<p>刪除的部分稍微麻煩一點，需要判斷刪除的元素位置，以剛剛我們建好的2-3樹為例：<br>
<img src="https://Z1Nhouse.github.io//post-images/1575799822760.PNG" alt=""></p>
<ul>
<li>
<p>假設今天要刪除<code>93</code>，不影響任何節點，直接刪除即可。</p>
</li>
<li>
<p>假設今天要刪除<code>16</code>，而16是11的右子節點，這個子節點中只有一個元素，則須將父節點的左子樹最大值拿來替補父節點，再用父節點替補刪除的節點16，如下圖所示。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575799953426.PNG" alt=""></p>
</li>
<li>
<p>假設今天要刪除<code>44</code>，44非葉節點，底下還有左子樹與右子樹，我們需要將左子樹的最大值來做替補。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575800160428.PNG" alt=""></p>
</li>
<li>
<p>假設今天我們要刪除根節點的<code>23</code>，那就顯得非常麻煩了，首先需要將根節點左子樹最大值11替補23，再將左子樹的11與其子節點11合併，最後將中子樹32與左子樹合併。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575800758833.PNG" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1575800805619.PNG" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1575800832554.PNG" alt=""></p>
</li>
<li>
<p>假設今天要刪除<code>77</code>(由根節點開始搜索，第一個碰到的77)，先將左子節點77替補父節點77，再將77與子節點87合併，再將根節點53替補為77與87的父節點，將左子樹的32替補為根節點，完成。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575800959792.PNG" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1575800962053.PNG" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1575800964694.PNG" alt=""></p>
</li>
</ul>
<h2 id="2-3-4樹">2-3-4樹</h2>
<p>為何會叫2-3-4樹？原因與2-3樹相同，只不過2-3-4樹的每個節點可以有2、3或4個子節點。</p>
<p>當一個節點有1個元素，則會有2個子節點，<br>
當一個節點有2個元素，則會有3個子節點，<br>
當一個節點有3個元素，則會有4個子節點。</p>
<p>與2-3樹的性質基本相同，可以參考2-3樹的介紹。</p>
<h3 id="2-3-4樹的元素新增">2-3-4樹的元素新增</h3>
<p>假設今天有一筆資料<code>{23,66,34,12,1,77,34,23,44,77,1}</code></p>
<p>加入資料23,66,34。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575801163272.PNG" alt=""><br>
再加入12時，根節點的元素變為4個，需要進行平衡，將中節點23往上提成根節點，12變為左子樹，右子樹為34與66。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575801237617.PNG" alt=""><br>
加入1,77。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575801270756.PNG" alt=""><br>
加入34後右子節點的元素變為4個，需要再次平衡，將中節點34往上提，左邊的34與右邊的66,77變為根節點的中、右子樹。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575801328302.PNG" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1575801331864.PNG" alt=""></p>
<p>加入23,44。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575801462256.PNG" alt=""><br>
加入77後需要再次平衡。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575801575613.PNG" alt=""></p>
<p>輸入1之後左子節點變為4個元素，需要將中間元素1往上提，但此時根節點也變為4個元素，再次將根節點的中間元素23往上提，左子節點為1，右子節點為34,66。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575801578418.PNG" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1575801597278.PNG" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1575801622916.PNG" alt=""></p>
<h3 id="2-3-4樹的元素刪除">2-3-4樹的元素刪除</h3>
<p>拿上方建好的2-3-4樹作為例子。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575801622916.PNG" alt=""></p>
<ul>
<li>
<p>刪除葉節點的<code>12</code>，毫無影響直接刪除即可。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575801850522.PNG" alt=""></p>
</li>
<li>
<p>刪除非葉節點的<code>1</code>，將其左子節點的1提上來替補，再將1與23合併，最後將根節點23替補為左子樹，將右子樹最小值替補根節點進行平衡。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575801856084.PNG" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1575801943259.PNG" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1575801858586.PNG" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1575802017706.PNG" alt=""></p>
</li>
<li>
<p>刪除根節點<code>34</code>，先將左子樹底下的最大值替補根節點，再將左子樹23替補34，最後將左子節點最大值替補父節點23。(請忽略敘述，直接看圖理解。)<br>
<img src="https://Z1Nhouse.github.io//post-images/1575802308925.png" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1575802189223.PNG" alt=""></p>
</li>
</ul>
<h2 id="红黑樹redblack-tree">红黑樹(Red–black tree)</h2>
<p>根據《算法導論》中紅黑樹必滿足以下五種特性：</p>
<ol>
<li>每個節點要不是紅色的，不然就是黑色的。</li>
<li>根節點一定是黑色的。</li>
<li>樹葉節點(最後的空節點)一定是黑的。</li>
<li>如果一個節點是紅色，那他的子節點都是黑的。</li>
<li>從任意一個節點到葉子節點，經過的黑色節點數是一樣的。</li>
</ol>
<p>保持黑平衡(從根節點到葉子節點所經過的黑色節點數一樣)的二元樹，嚴格來說不是平衡二元樹。</p>
<h3 id="2-3-4樹轉換成红黑樹">2-3-4樹轉換成红黑樹</h3>
<p>一個2-3-4樹可以轉換成不止一種型態的紅黑樹，但一個紅黑樹僅能轉換成一種2-3-4樹。</p>
<p>假設根節點僅有一個元素，則將之設為紅黑樹的根節點；<br>
若根節點有一個以上的元素，則隨意取一個設為紅黑樹的根節點，要注意的是，同個節點拆分出來的元素是紅色的。</p>
<p>這是取自<a href="https://www.cnblogs.com/nullzx/p/6128416.html">nullzx</a>的圖<br>
<img src="https://Z1Nhouse.github.io//post-images/1575802847023.jpg" alt=""><br>
大致了解一下即可，只要了解二元搜索樹及紅黑樹的性質就可以輕鬆轉換。</p>
<blockquote>
<p>雖然紅黑樹和AVL樹的時間複雜度都為O(logn)，但是紅黑樹的高度(2logn)比AVL樹(logn)高，所以在紅黑樹上「查找」較AVL樹慢，儘管如此，紅黑樹卻比AVL樹重要且常用，原因為紅黑樹添加與刪除元素的速度較AVL樹快。<strong>若光只查詢，AVL樹查詢的速度快於紅黑樹；若需要頻繁的新增與刪除元素，紅黑樹則優於AVL樹。</strong></p>
</blockquote>
<h2 id="b樹b-tree">B樹(B-tree)</h2>
<p>B樹適用於讀寫相對大的數據塊的存儲系統，例如磁碟。B樹減少定位記錄時所經歷的中間過程，從而加快存取速度。B樹這種資料結構可以用來描述外部存儲。這種資料結構常被應用在資料庫和文件系統的實現上。</p>
<p>2-3與2-3-4樹都是B樹的特例。</p>
<p>若非空樹，則滿足：</p>
<ol>
<li>每個節點至多有m棵子樹(至多m-1個元素)</li>
<li>若根節點非終端，則至少有兩棵子樹。</li>
<li>除根節點外的所有非葉節點至少有⌈m/2⌉棵子樹。</li>
<li>[n,P0,K1,P1,K2....Kn,Pn] n=節點中元素個數；Ki為節點的元素且K1&lt;K2...；Pi為指向子樹根節點的指針</li>
<li>所有的葉節點出現在同一level。</li>
</ol>
<p>在此不多演示B樹的新增資料與刪除了，請參考2-3樹與2-3-4樹。<br>
詳情見：<a href="https://zh.wikipedia.org/wiki/B%E6%A0%91">B樹維基百科</a></p>
<h2 id="b樹">B+樹</h2>
<p>常用於數據庫和文件系統中的一種用於查找的資料結構。</p>
<p>B+與B樹的主要差異為：</p>
<ol>
<li>B+樹具有n個元素的節點只含有n棵子樹，每個元素對應一棵子樹，但是B樹n個元素會有n+1棵子樹。</li>
<li>葉節點包含資料，所有非葉節點則是索引作用，索引只含有對應子樹的最大元素和指向該子樹的指針，而B樹每個節點都是一個元素。</li>
<li>所有葉節點鏈結成一個單鏈表(由小到大)。</li>
</ol>
<p>B+樹示意圖(此處的關鍵字代表元素)<br>
<img src="https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232853119-1460626460.png" alt=""><br>
圖片來源nullzx</p>
<h3 id="b樹的元素新增">B+樹的元素新增</h3>
<p>假設今天有一筆資料<code>{33,21,11,4,66,77,32,56}</code>，而此B+樹為3階。</p>
<p>首先加入資料33,21。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575803906400.PNG" alt=""><br>
加入11時由於此樹為3階，因此需要進行分裂，在此需要取中間值21作為索引key。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575803913991.PNG" alt=""><br>
加入4,66，需要進行分裂，將中間值33往上提作為索引key。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575804030133.PNG" alt=""><br>
加入77。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575804121178.PNG" alt=""><br>
加入32,56。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575804124551.PNG" alt=""></p>
<h3 id="b樹的元素刪除">B+樹的元素刪除</h3>
<p>使用上方建的B+樹進行示範。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575804124551.PNG" alt=""></p>
<ul>
<li>
<p>刪除<code>32</code>，直接刪除即可。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575804245714.PNG" alt=""></p>
</li>
<li>
<p>刪除<code>66</code>，要注意的是，刪除的是資料項66，而非索引的66，將剩餘的77往上提作為索引key。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575804267222.PNG" alt=""></p>
</li>
</ul>
<p>在此省略了刪除11的步驟。</p>
<ul>
<li>刪除<code>21</code>，將21索引與資料項刪除，將資料4與33,56連結在一起，再將根部的索引33與右子樹的索引77合併。<br>
<img src="https://Z1Nhouse.github.io//post-images/1575804443747.PNG" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1575804446458.PNG" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1575804449235.PNG" alt=""><br>
<img src="https://Z1Nhouse.github.io//post-images/1575804452522.PNG" alt=""></li>
</ul>
<p>就這樣~</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%BD%95%E8%AC%82%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A8%B9">何謂「平衡搜索樹」？</a></li>
<li><a href="#%E5%B0%88%E6%A5%AD%E8%A1%93%E8%AA%9E">專業術語</a></li>
<li><a href="#2-3%E6%A8%B9">2-3樹</a>
<ul>
<li><a href="#2-3%E6%A8%B9%E7%9A%84%E5%85%83%E7%B4%A0%E6%96%B0%E5%A2%9E">2-3樹的元素新增</a></li>
<li><a href="#2-3%E6%A8%B9%E7%9A%84%E5%85%83%E7%B4%A0%E5%88%AA%E9%99%A4">2-3樹的元素刪除</a></li>
</ul>
</li>
<li><a href="#2-3-4%E6%A8%B9">2-3-4樹</a>
<ul>
<li><a href="#2-3-4%E6%A8%B9%E7%9A%84%E5%85%83%E7%B4%A0%E6%96%B0%E5%A2%9E">2-3-4樹的元素新增</a></li>
<li><a href="#2-3-4%E6%A8%B9%E7%9A%84%E5%85%83%E7%B4%A0%E5%88%AA%E9%99%A4">2-3-4樹的元素刪除</a></li>
</ul>
</li>
<li><a href="#%E7%BA%A2%E9%BB%91%E6%A8%B9redblack-tree">红黑樹(Red–black tree)</a>
<ul>
<li><a href="#2-3-4%E6%A8%B9%E8%BD%89%E6%8F%9B%E6%88%90%E7%BA%A2%E9%BB%91%E6%A8%B9">2-3-4樹轉換成红黑樹</a></li>
</ul>
</li>
<li><a href="#b%E6%A8%B9b-tree">B樹(B-tree)</a></li>
<li><a href="#b%E6%A8%B9">B+樹</a>
<ul>
<li><a href="#b%E6%A8%B9%E7%9A%84%E5%85%83%E7%B4%A0%E6%96%B0%E5%A2%9E">B+樹的元素新增</a></li>
<li><a href="#b%E6%A8%B9%E7%9A%84%E5%85%83%E7%B4%A0%E5%88%AA%E9%99%A4">B+樹的元素刪除</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://Z1Nhouse.github.io//post/XmgX1Z_xP">
              <h3 class="post-title">
                Chrome必裝擴展—Tampermonkey油猴，只要有腳本什麼都能辦到！
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'e5c1a1597ef592d472ea',
    clientSecret: 'f7693b11e4023f6556063c4302faab8119ed81aa',
    repo: 'z1nhouse.github.io',
    owner: 'z1nhouse',
    admin: ['z1nhouse'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://Z1Nhouse.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()

  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

  // This should probably be throttled.
  // Especially because it triggers during smooth scrolling.
  // https://lodash.com/docs/4.17.10#throttle
  // You could do like...
  // window.addEventListener("scroll", () => {
  //    _.throttle(doThatStuff, 100);
  // });
  // Only not doing it here to keep this Pen dependency-free.

  window.addEventListener("scroll", event => {
    let fromTop = window.scrollY;

    mainNavLinks.forEach((link, index) => {
      let section = document.getElementById(decodeURI(link.hash).substring(1));
      let nextSection = null
      if (mainNavLinks[index + 1]) {
        nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      }
      if (section.offsetTop <= fromTop) {
        if (nextSection) {
          if (nextSection.offsetTop > fromTop) {
            link.classList.add("current");
          } else {
            link.classList.remove("current");    
          }
        } else {
          link.classList.add("current");
        }
      } else {
        link.classList.remove("current");
      }
    });
  });

</script>

      </div>
    </div>
  </body>
</html>
